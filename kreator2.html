<!-- kreator2.html v0.022 UX: panel poza obszarem (warning, przezroczysto≈õƒá, toggle przycisk√≥w) -->
<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kreator Paneli (Final Layout)</title>
    <style>
        :root {
            --primary: #5d3a75;
            --bg: #f4f6f9;
            --text: #333;
            --border: #ccc;
            --active-border: #28a745;
            --toolbar-bg: #fff;
            --danger: #dc3545;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
            height: 95vh;
            box-sizing: border-box;
        }

        .layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            height: 100%;
        }

        /* --- LEWA KOLUMNA (KONFIGURACJA) --- */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
            overflow-y: auto;
            padding-right: 5px;
        }

        .card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        h3 { margin-top: 0; font-size: 1.1em; border-bottom: 2px solid #f0f0f0; padding-bottom: 8px; margin-bottom: 12px; color: #444; }
        label { display: block; font-size: 0.85em; font-weight: 600; color: #555; margin-bottom: 4px; }
        input[type="number"], select { width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; box-sizing: border-box; }

        /* Przyciski */
        button { cursor: pointer; transition: 0.2s; }
        .btn-secondary { background: #e2e6ea; color: #333; border: 1px solid #ced4da; padding: 6px 12px; border-radius: 4px; font-size: 0.9em; }
        .btn-secondary:hover { background: #dbe2e8; }
        .btn-danger { background: #fff5f5; color: var(--danger); border: 1px solid #f5c6cb; padding: 8px; border-radius: 4px; width: 100%; margin-top: 10px;}
        .btn-danger:hover { background: #f8d7da; }
        .btn-add-segment { width: 100%; background: #e9ecef; border: 1px solid #ced4da; color: #333; padding: 8px; border-radius: 4px; margin-top: 5px; font-weight: bold;}

        /* Lista Odcink√≥w */
        .segment-row { display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #fafafa; border-bottom: 1px solid #eee; font-size: 0.9em; }
        .segment-icon { font-size: 1.2em; margin-right: 8px; color: #999; }
        .btn-x { padding: 2px 8px; font-size: 0.8em; color: var(--danger); border: 1px solid var(--danger); background: #fff; border-radius: 4px; }

        /* Lista Wariant√≥w (Config) */
        .variant-config-list { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px; }
        .variant-tag { background: #eee; padding: 4px 8px; border-radius: 12px; font-size: 0.85em; display: flex; align-items: center; gap: 5px; }
        .variant-tag span { cursor: pointer; color: #999; font-weight: bold; }
        .variant-tag span:hover { color: var(--danger); }

        /* Mapowanie */
        .mapping-item { background: #fcfcfc; border: 1px solid #eee; padding: 8px; margin-bottom: 5px; border-radius: 4px; display: flex; gap: 10px; align-items: center; }
        .map-swatch { width: 24px; height: 24px; border-radius: 50%; border: 1px solid #ccc; flex-shrink: 0; }
        .map-select { font-size: 0.85em; padding: 4px; }

        /* Podsumowanie */
        .price-summary { background: #e8f5e9; border: 1px solid #c8e6c9; padding: 10px; border-radius: 6px; margin-top: 10px; }
        .total-price { font-size: 1.4em; font-weight: bold; color: #2e7d32; text-align: right; }

        /* --- PRAWA STRONA (PROJEKT) --- */
        .project-area {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        /* TOP BAR */
        .top-bar {
            background: var(--toolbar-bg);
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            min-height: 50px;
        }
        .top-bar-title { font-size: 0.8em; font-weight: bold; color: #888; text-transform: uppercase; margin-right: 5px; }
        .panel-btn {
            background: #fff; border: 1px solid #ccc; padding: 8px 15px; border-radius: 4px;
            font-weight: bold; color: #333; font-size: 0.95em; display: flex; align-items: center; gap: 5px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
        }
        .panel-btn:hover { background: #f0f2f5; border-color: #aaa; transform: translateY(-1px); }
        .panel-btn.active {
            background: #e8f5e9;
            border: 2px solid #28a745;
            color: #28a745;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.2);
            transform: scale(1.05);
        }
        .panel-btn span { font-size: 0.8em; font-weight: normal; color: #666; }

        .btn-add-panel {
            background: #28a745; color: white; border: 2px solid #28a745;
            padding: 8px 20px; border-radius: 4px; font-weight: bold; font-size: 0.95em;
            margin-left: 10px; cursor: pointer; transition: 0.2s;
        }
        .btn-add-panel:hover { background: #218838; border-color: #1e7e34; transform: translateY(-1px); }
        .btn-add-panel:disabled { background: #ccc; border-color: #ccc; cursor: not-allowed; opacity: 0.6; }

        .mode-toggle {
            background: var(--primary); color: white; border: 2px solid var(--primary);
            padding: 8px 15px; border-radius: 4px; font-weight: bold; font-size: 0.9em;
            margin-left: auto;
        }
        .mode-toggle:hover { background: #4a2e5e; border-color: #4a2e5e; }

        /* WORKSPACE */
        .workspace {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }

        /* LEFT VERTICAL BAR (TOOLS) */
        .tools-bar {
            width: 60px;
            background: #fcfcfc;
            border-right: 1px solid #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 5px;
            gap: 10px;
            overflow-y: auto;
            z-index: 2;
        }

        .tool-btn {
            width: 40px; height: 40px; border-radius: 50%;
            border: 2px solid #ddd; cursor: pointer; position: relative; flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: transform 0.1s;
            background-size: cover; background-position: center;
        }
        .tool-btn:hover { transform: scale(1.1); z-index: 3; }
        .tool-btn.active { border-color: var(--active-border); transform: scale(1.1); box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.2); }
        .tool-btn.eraser {
            background: #fff url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23d32f2f" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>') no-repeat center;
            border-color: #f5c6cb;
        }
        .tool-btn.eraser.active { background-color: #ffecec; border-color: #dc3545; box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.2); }

        .tool-sep { width: 60%; height: 1px; background: #ddd; margin: 5px 0; }

        /* CANVAS */
        .canvas-wrapper {
            flex-grow: 1;
            background: #eef1f5;
            overflow: auto;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        svg { display: block; background: #f8f9fa; box-shadow: 0 5px 25px rgba(0,0,0,0.05); }

        .wall-bg { fill: #e0e0e0; stroke: #777; stroke-width: 2; }
        .panel-rect { stroke: rgba(255,255,255,0.3); stroke-width: 2; cursor: crosshair; transition: fill-opacity 0.1s; }
        .panel-rect.delete-mode { cursor: not-allowed; }
        .panel-rect:hover { stroke: #666; stroke-width: 3px; filter: brightness(1.1); }
        .dim-text-panel { font-size: 11px; font-family: Arial, sans-serif; font-weight: bold; pointer-events: none; }
        .dim-text-external { font-size: 11px; font-family: Arial, sans-serif; fill: #444; font-weight: normal; }
        .dim-line { stroke: #444; stroke-width: 1; stroke-dasharray: 2,2; }

        .canvas-zoom {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(255,255,255,0.9); padding: 5px 10px; border-radius: 20px;
            display: flex; gap: 5px; border: 1px solid #ccc; align-items: center;
            font-size: 0.85em; font-weight: bold; color: #555;
        }

        /* Zapis */
        .save-slot { background: #f8f9fa; border: 1px solid #eee; padding: 8px; margin-bottom: 5px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }

        /* Komunikaty projektu */
        .project-messages {
            position: relative;
            min-height: 0;
            transition: all 0.3s ease;
        }
        .project-message {
            padding: 12px 20px;
            margin: 10px 20px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            font-size: 0.9em;
            animation: slideDown 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .project-message-content {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        .project-message-icon {
            font-size: 1.2em;
            font-weight: bold;
        }
        .project-message-actions {
            display: flex;
            gap: 8px;
        }
        .project-message-success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }
        .project-message-error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }
        .project-message-warning {
            background: #fff3cd;
            color: #856404;
            border-left: 4px solid #ffc107;
        }
        .project-message-info {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #17a2b8;
        }
        .project-message-close {
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            opacity: 0.6;
            padding: 0 5px;
            line-height: 1;
        }
        .project-message-close:hover {
            opacity: 1;
        }
        .project-message-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.2s;
        }
        .project-message-btn-primary {
            background: #28a745;
            color: white;
        }
        .project-message-btn-primary:hover {
            background: #218838;
        }
        .project-message-btn-secondary {
            background: #6c757d;
            color: white;
        }
        .project-message-btn-secondary:hover {
            background: #5a6268;
        }
        @keyframes slideDown {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @media (max-width: 900px) {
            .layout { grid-template-columns: 1fr; height: auto; display: block; }
            .controls { height: auto; margin-bottom: 20px; overflow: visible; }
            .project-area { height: 600px; }
        }
    </style>
</head>
<body>

<div class="layout">

    <!-- 1. LEWA KOLUMNA (KONFIGURACJA) -->
    <div class="controls">

        <!-- Kszta≈Çt obszaru roboczego -->
        <div class="card">
            <h3>1. Kszta≈Çt obszaru roboczego</h3>
            <div id="segmentsContainer"></div>

            <div style="background:#fdfdfd; padding:10px; border:1px dashed #ccc; margin-top:10px; border-radius:4px;">
                <div class="row-inputs" style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:5px;">
                    <input type="number" id="segWidth" placeholder="Szer.">
                    <input type="number" id="segStartHeight" placeholder="np. 140">
                    <input type="number" id="segEndHeight" placeholder="Wys. ko≈Ñc.">
                </div>
                <button class="btn-add-segment" onclick="addSegment()">+ Dodaj Segment</button>
            </div>
            <button class="btn-secondary" style="width:100%; margin-top:10px; background:#e8f5e9; border-color:#81c784; color:#2e7d32;" onclick="loadPresetWorkspace()">üìã Wczytaj przyk≈Çad</button>
            <button class="btn-danger" onclick="resetWall()">Resetuj Obszar</button>
        </div>

        <!-- Konfiguracja Paneli -->
        <div class="card">
            <h3>2. Konfiguracja Paneli</h3>
            <p style="font-size:0.8em; color:#666; margin-bottom:5px;">Zdefiniuj wymiary paneli (szer √ó wys) dostƒôpne do uk≈Çadania.</p>
            <div class="row-inputs" style="display:grid; grid-template-columns:1fr 1fr auto; gap:5px;">
                <input type="number" id="newVariantWidth" placeholder="Szer.">
                <input type="number" id="newVariantHeight" placeholder="Wys.">
                <button class="btn-secondary" onclick="addVariantDefinition()">Dodaj</button>
            </div>
            <div id="variantConfigList" class="variant-config-list"></div>
        </div>

        <!-- Wycena i Mapowanie -->
        <div class="card" style="border-left: 5px solid #28a745;">
            <h3>3. Wycena i Materia≈Çy</h3>

            <div id="mappingContainer" style="margin-bottom:15px;"></div>

            <div style="font-size:0.9em; margin-bottom:10px; display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                <label style="font-weight:normal;"><input type="checkbox" id="optFoam" onchange="recalculatePrice()"> Podw√≥jna pianka</label>
                <label style="font-weight:normal;"><input type="checkbox" id="optVelcro" onchange="recalculatePrice()"> Rzep monta≈ºowy</label>
                <label style="font-weight:normal;"><input type="checkbox" id="optShipping" checked onchange="recalculatePrice()"> Wysy≈Çka</label>
            </div>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                <div class="form-group">
                    <label>Otwory na kontakt (szt):</label>
                    <input type="number" id="optOutlets" value="0" min="0" onchange="recalculatePrice()">
                </div>
                <div class="form-group">
                    <label>Klej (szt):</label>
                    <input type="number" id="optGlue" value="0" min="0" onchange="recalculatePrice()">
                </div>
            </div>

            <div class="price-summary">
                <div class="total-price" id="totalPriceDisplay">0.00 z≈Ç</div>
                <div style="font-size:0.8em; color:#555; margin-top:5px;" id="priceDetails"></div>
            </div>
        </div>

        <!-- Zapis -->
        <div class="card">
            <h3>Zapisane Projekty</h3>
            <button class="btn-secondary" style="width:100%; margin-bottom:10px; background:#e3f2fd; border-color:#90caf9; color:#1565c0;" onclick="saveCurrentLayout()">üíæ Zapisz obecny uk≈Çad</button>
            <div id="savesContainer"></div>
        </div>

    </div>

    <!-- 2. PRAWA STRONA (PROJEKT) -->
    <div class="project-area">

        <!-- NAG≈Å√ìWEK PROJEKTU -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px 20px; border-radius: 8px 8px 0 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <h2 style="margin: 0; font-size: 1.3em; font-weight: 600;">Projekt</h2>
        </div>

        <!-- TOP BAR: SZYBKIE DODAWANIE -->
        <div class="top-bar" id="topBar">
            <div class="top-bar-title">Dodaj panel:</div>
            <div id="topVariantsButtons" style="display:flex; gap:8px; overflow-x:auto;"></div>
            <div class="top-bar-title" style="margin-left:auto; font-size:0.75em; color:#999;">Kliknij w obszar aby ustawiƒá pozycjƒô preview</div>
        </div>

        <!-- KOMUNIKATY PROJEKTU -->
        <div id="projectMessages" class="project-messages"></div>

        <!-- WORKSPACE -->
        <div class="workspace">
            <!-- LEFT BAR: NARZƒòDZIA -->
            <div class="tools-bar" id="toolsBar">
                <!-- Generowane JS (Kolory + Gumka) -->
            </div>

            <!-- CANVAS -->
            <div class="canvas-wrapper">
                <div id="svgWrapper"></div>

                <div class="canvas-zoom">
                    <button onclick="changeZoom(-0.1)" class="btn-secondary" style="padding:2px 6px;">-</button>
                    <span id="zoomLabel">100%</span>
                    <button onclick="changeZoom(0.1)" class="btn-secondary" style="padding:2px 6px;">+</button>
                    <span style="color:#ccc">|</span>
                    <button onclick="undoPanel()" class="btn-secondary" title="Cofnij ostatni panel" style="padding:2px 6px;">‚Ü©</button>
                    <button onclick="clearWorkspace()" class="btn-secondary" title="Wyczy≈õƒá obszar roboczy" style="padding:2px 6px;">üóëÔ∏è</button>
                </div>
            </div>
        </div>
    </div>

</div>

<script>
    // --- DANE CENOWE ---
    // ROZMIARY PANELI - Tabele cenowe (Standard/Premium/Exclusive)
    const RozmStandard = {
        // KLASYCZNE
        "20x20": 21, "20x30": 22, "20x40": 24, "30x30": 24, "30x40": 25, "30x50": 26, "30x60": 28,
        "30x70": 35, "30x80": 39, "30x90": 45, "30x100": 50, "30x120": 75, "40x40": 26, "40x50": 32,
        "40x60": 35, "40x70": 46, "40x80": 53, "40x90": 60, "40x100": 69, "40x120": 89, "50x50": 43,
        "50x60": 51, "50x70": 61, "60x60": 63,
        // LONGI
        "20x50": 24, "20x60": 25, "20x70": 29, "20x80": 29, "20x90": 33, "20x100": 45, "20x110": 50,
        "20x120": 55, "20x130": 59, "20x140": 63, "20x150": 67, "20x160": 70, "20x170": 78, "20x180": 85,
        "20x190": 94, "20x200": 100, "20x210": 109, "20x220": 115, "20x230": 120, "20x240": 125,
        "20x250": 135, "20x260": 140, "15x50": 24, "15x60": 25, "15x70": 29, "15x80": 29, "15x90": 33,
        "15x100": 45, "15x110": 50, "15x120": 55, "15x130": 58, "15x140": 60, "15x150": 63, "15x160": 70,
        "15x170": 78, "15x180": 85, "15x190": 94, "15x200": 100, "15x210": 109, "15x220": 115,
        "15x230": 120, "15x240": 125, "15x250": 135, "15x260": 140, "10x50": 24, "10x60": 24, "10x70": 29,
        "10x80": 29, "10x90": 29, "10x100": 39, "10x110": 45, "10x120": 50, "10x130": 54, "10x140": 58,
        "10x150": 61, "10x160": 65, "10x170": 73, "10x180": 80, "10x190": 88, "10x200": 95, "10x210": 105,
        "10x220": 110, "10x230": 115, "10x240": 120, "10x250": 130, "10x260": 135
    };

    const RozmPremium = {
        // KLASYCZNE
        "20x20": 25, "20x30": 28, "20x40": 29, "30x30": 28, "30x40": 30, "30x50": 31, "30x60": 33,
        "30x70": 40, "30x80": 46, "30x90": 51, "30x100": 59, "30x120": 85, "40x40": 31, "40x50": 37,
        "40x60": 40, "40x70": 51, "40x80": 60, "40x90": 68, "40x100": 79, "40x120": 99, "50x50": 49,
        "50x60": 58, "50x70": 71, "60x60": 73,
        // LONGI
        "20x50": 30, "20x60": 31, "20x70": 34, "20x80": 34, "20x90": 38, "20x100": 50, "20x110": 55,
        "20x120": 60, "20x130": 64, "20x140": 68, "20x150": 71, "20x160": 75, "20x170": 85, "20x180": 90,
        "20x190": 100, "20x200": 110, "20x210": 115, "20x220": 120, "20x230": 125, "20x240": 130,
        "20x250": 139, "20x260": 145, "15x50": 30, "15x60": 31, "15x70": 34, "15x80": 34, "15x90": 34,
        "15x100": 50, "15x110": 55, "15x120": 60, "15x130": 64, "15x140": 68, "15x150": 71, "15x160": 75,
        "15x170": 85, "15x180": 90, "15x190": 100, "15x200": 110, "15x210": 115, "15x220": 120,
        "15x230": 125, "15x240": 130, "15x250": 139, "15x260": 145, "10x50": 28, "10x60": 28, "10x70": 31,
        "10x80": 31, "10x90": 31, "10x100": 39, "10x110": 45, "10x120": 50, "10x130": 54, "10x140": 58,
        "10x150": 61, "10x160": 65, "10x170": 75, "10x180": 80, "10x190": 90, "10x200": 95, "10x210": 105,
        "10x220": 110, "10x230": 115, "10x240": 120, "10x250": 130, "10x260": 135
    };

    const RozmExclusive = {
        // KLASYCZNE
        "20x20": 27, "20x30": 30, "20x40": 32, "30x30": 32, "30x40": 35, "30x50": 36, "30x60": 38,
        "30x70": 45, "30x80": 51, "30x90": 56, "30x100": 65, "30x120": 90, "40x40": 35, "40x50": 42,
        "40x60": 45, "40x70": 55, "40x80": 65, "40x90": 70, "40x100": 85, "40x120": 105, "50x50": 51,
        "50x60": 60, "50x70": 75, "60x60": 78,
        // LONGI
        "20x50": 33, "20x60": 34, "20x70": 39, "20x80": 39, "20x90": 43, "20x100": 55, "20x110": 60,
        "20x120": 65, "20x130": 69, "20x140": 73, "20x150": 77, "20x160": 80, "20x170": 90, "20x180": 95,
        "20x190": 110, "20x200": 115, "20x210": 120, "20x220": 125, "20x230": 130, "20x240": 135,
        "20x250": 145, "20x260": 150, "15x50": 33, "15x60": 34, "15x70": 39, "15x80": 39, "15x90": 39,
        "15x100": 55, "15x110": 60, "15x120": 65, "15x130": 69, "15x140": 73, "15x150": 77, "15x160": 80,
        "15x170": 90, "15x180": 95, "15x190": 110, "15x200": 115, "15x210": 120, "15x220": 125,
        "15x230": 130, "15x240": 135, "15x250": 145, "15x260": 150, "10x50": 32, "10x60": 32, "10x70": 34,
        "10x80": 34, "10x90": 34, "10x100": 44, "10x110": 49, "10x120": 55, "10x130": 59, "10x140": 63,
        "10x150": 67, "10x160": 70, "10x170": 80, "10x180": 85, "10x190": 95, "10x200": 100, "10x210": 110,
        "10x220": 115, "10x230": 120, "10x240": 125, "10x250": 135, "10x260": 140
    };

    // --- KOLEKCJE TKANIN ---
    const Collections = {
        Standard: ['DIANA', 'LUNA', 'SWEET', 'TANGO', 'NUBUK', 'TREND', 'OLIMP', 'TRINITY'],
        Premium: ['KRONOS', 'RODOS', 'FOREST', 'CROWN', 'MONOLITH', 'EVO', 'FRESH', 'PRESTON'],
        Exclusive: ['VELVET', 'ALCANTARA', 'LOFT', 'JAZZ']
    };

    // Paleta wizualna
    const visualPalette = [
        { hex: '#5d3a75', name: 'Fiolet' }, { hex: '#8e8e93', name: 'Szary' },
        { hex: '#d2b48c', name: 'Be≈º' }, { hex: '#1a2a6c', name: 'Granat' },
        { hex: '#2d5a27', name: 'Ziele≈Ñ' }, { hex: '#e6bece', name: 'Pudrowy' },
        { hex: '#d4af37', name: '≈ª√≥≈Çty' }, { hex: '#333333', name: 'Grafit' }
    ];
    // Dekor (Base64)
    const floralTex = "data:image/svg+xml,%3Csvg width='50' height='50' viewBox='0 0 50 50' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='50' height='50' fill='%236a4c93'/%3E%3Ccircle cx='25' cy='25' r='10' fill='%23ffffff' opacity='0.2'/%3E%3Cpath d='M25 15 L35 25 L25 35 L15 25 Z' fill='%23ffffff' opacity='0.2'/%3E%3C/svg%3E";
    const visualTextures = [{ file: floralTex, name: 'Dekor' }];

    // --- STAN ---
    let wallData = { segments: [] };
    let variants = [
        {width: 30, height: 100},
        {width: 20, height: 140},
        {width: 30, height: 40}
    ]; // Domy≈õlne wymiary
    let panels = []; // {width, height, x, y, style}
    let activeTool = { type: 'color', value: visualPalette[0].hex }; // 'eraser' lub {type, value}
    let styleMapping = {};
    let layoutMode = 'horizontal'; // 'horizontal' | 'vertical'
    let zoomLevel = 1.0;
    let selectedPanelSize = null; // {width, height} - wybrany panel do dodania (hover)
    let lastUsedPanelSize = null; // {width, height} - ostatnio dodany panel (auto-preview)
    let previewPosition = null; // {x, y} - pozycja preview (z myszki lub smart snap)
    let previewLocked = false; // Czy preview jest "zamro≈ºony" po snapie
    let selectedVariant = null; // {width, height} - aktywnie wybrany rozmiar (dla pod≈õwietlenia)
    const STORAGE_KEY = 'panelConfig_V6_Saves';

    // --- SYSTEM KOMUNIKAT√ìW PROJEKTU ---
    function showProjectMessage(text, type = 'info', duration = 4000) {
        const container = document.getElementById('projectMessages');

        // Usu≈Ñ poprzednie komunikaty
        container.innerHTML = '';

        // Ikony dla typ√≥w
        const icons = {
            success: '‚úì',
            info: '‚Ñπ',
            warning: '‚ö†',
            error: '‚úï'
        };

        const messageDiv = document.createElement('div');
        messageDiv.className = `project-message project-message-${type}`;
        messageDiv.innerHTML = `
            <div class="project-message-content">
                <span class="project-message-icon">${icons[type]}</span>
                <span>${text}</span>
            </div>
            <button class="project-message-close" onclick="this.parentElement.remove()">√ó</button>
        `;

        container.appendChild(messageDiv);

        // Auto-hide po okre≈õlonym czasie
        if (duration > 0) {
            setTimeout(() => {
                if (messageDiv.parentElement) {
                    messageDiv.remove();
                }
            }, duration);
        }
    }

    function showProjectConfirm(text, onConfirm) {
        const container = document.getElementById('projectMessages');

        // Usu≈Ñ poprzednie komunikaty
        container.innerHTML = '';

        const messageDiv = document.createElement('div');
        messageDiv.className = 'project-message project-message-warning';
        messageDiv.innerHTML = `
            <div class="project-message-content">
                <span class="project-message-icon">‚ö†</span>
                <span>${text}</span>
            </div>
            <div class="project-message-actions">
                <button class="project-message-btn project-message-btn-primary" onclick="handleConfirmYes()">TAK</button>
                <button class="project-message-btn project-message-btn-secondary" onclick="handleConfirmNo()">ANULUJ</button>
            </div>
        `;

        container.appendChild(messageDiv);

        // Przechowuj callback w globalnej zmiennej tymczasowej
        window._projectConfirmCallback = () => {
            messageDiv.remove();
            onConfirm();
        };
    }

    function handleConfirmYes() {
        if (window._projectConfirmCallback) {
            window._projectConfirmCallback();
            delete window._projectConfirmCallback;
        }
    }

    function handleConfirmNo() {
        const container = document.getElementById('projectMessages');
        container.innerHTML = '';
        delete window._projectConfirmCallback;
    }

    // --- INIT ---
    document.addEventListener('DOMContentLoaded', () => {
        renderSegmentsList();
        renderVariantConfig(); // Lewy panel (konfiguracja)
        renderTopBar();        // G√≥rny pasek (u≈ºycie)
        renderToolsBar();      // Pasek narzƒôdzi
        renderSaves();
        draw();
        updateMappingUI();

        // Obs≈Çuga klikniƒôƒá w obszar roboczy
        const svgWrapper = document.getElementById('svgWrapper');
        svgWrapper.addEventListener('click', onCanvasClick);
        svgWrapper.addEventListener('mousemove', onCanvasMouseMove);
    });

    // --- 1. ZARZƒÑDZANIE WARIANTAMI (SEKCJA 2 + TOP BAR) ---
    function addVariantDefinition() {
        const w = parseFloat(document.getElementById('newVariantWidth').value);
        const h = parseFloat(document.getElementById('newVariantHeight').value);

        if (w > 0 && h > 0) {
            const exists = variants.some(v => v.width === w && v.height === h);
            if (!exists) {
                variants.push({width: w, height: h});
                variants.sort((a,b) => (b.width * b.height) - (a.width * a.height));
                renderVariantConfig();
                renderTopBar();
                document.getElementById('newVariantWidth').value = '';
                document.getElementById('newVariantHeight').value = '';
            }
        }
    }

    function removeVariantDefinition(w, h) {
        variants = variants.filter(v => !(v.width === w && v.height === h));
        renderVariantConfig();
        renderTopBar();
    }

    function renderVariantConfig() {
        // Lista w sekcji 2 (do usuwania)
        const c = document.getElementById('variantConfigList');
        c.innerHTML = '';
        variants.forEach(v => {
            const tag = document.createElement('div');
            tag.className = 'variant-tag';
            tag.innerHTML = `${v.width}√ó${v.height} cm <span onclick="removeVariantDefinition(${v.width}, ${v.height})">&times;</span>`;
            c.appendChild(tag);
        });
    }

    function selectVariant(width, height) {
        selectedVariant = {width, height};
        lastUsedPanelSize = {width, height};
        previewPosition = null; // Reset preview position przy zmianie rozmiaru
        previewLocked = false; // Odblokuj preview przy zmianie rozmiaru
        renderTopBar(); // Od≈õwie≈º aby pokazaƒá active state
        draw();
    }

    function addPanelFromButton() {
        if (!lastUsedPanelSize) {
            showProjectMessage('Najpierw wybierz rozmiar panelu!', 'warning');
            return;
        }
        addPanel(lastUsedPanelSize.width, lastUsedPanelSize.height);
    }

    function renderTopBar() {
        // Przyciski w Top Bar (wyb√≥r rozmiaru)
        const c = document.getElementById('topVariantsButtons');
        c.innerHTML = '';

        variants.forEach(v => {
            const btn = document.createElement('button');
            const isActive = selectedVariant && selectedVariant.width === v.width && selectedVariant.height === v.height;
            btn.className = `panel-btn ${isActive ? 'active' : ''}`;
            btn.innerHTML = `${v.width}√ó${v.height}`;
            btn.onmouseenter = () => {
                if (!isActive) {
                    selectedPanelSize = {width: v.width, height: v.height};
                    draw();
                }
            };
            btn.onmouseleave = () => {
                selectedPanelSize = null;
                draw();
            };
            btn.onclick = () => {
                selectedPanelSize = null;
                // Toggle: je≈õli ju≈º active, odkliknij (wy≈ÇƒÖcz preview)
                if (isActive) {
                    selectedVariant = null;
                    lastUsedPanelSize = null;
                    previewPosition = null;
                    previewLocked = false;
                } else {
                    selectVariant(v.width, v.height);
                }
                renderTopBar();
                draw();
            };
            c.appendChild(btn);
        });

        // Przycisk Dodaj
        const addBtn = document.createElement('button');
        addBtn.className = 'btn-add-panel';
        addBtn.innerHTML = '‚úì Dodaj';
        addBtn.disabled = !lastUsedPanelSize;
        addBtn.onclick = addPanelFromButton;
        c.appendChild(addBtn);
    }

    // --- 2. NARZƒòDZIA (LEFT VERTICAL BAR) ---
    function renderToolsBar() {
        const c = document.getElementById('toolsBar');
        c.innerHTML = '';

        // 1. Gumka
        const eraser = document.createElement('div');
        eraser.className = `tool-btn eraser ${activeTool==='eraser'?'active':''}`;
        eraser.title = "Usu≈Ñ Panel (Kliknij panel aby usunƒÖƒá)";
        eraser.onclick = () => setActiveTool('eraser');
        c.appendChild(eraser);

        c.appendChild(document.createElement('div')).className = 'tool-sep';

        // 2. Kolory
        visualPalette.forEach(item => {
            const el = document.createElement('div');
            const isActive = activeTool.type === 'color' && activeTool.value === item.hex;
            el.className = `tool-btn ${isActive?'active':''}`;
            el.style.backgroundColor = item.hex;
            el.title = item.name;
            el.onclick = () => setActiveTool({ type: 'color', value: item.hex });
            c.appendChild(el);
        });

        c.appendChild(document.createElement('div')).className = 'tool-sep';

        // 3. Tekstury
        visualTextures.forEach(item => {
            const el = document.createElement('div');
            const isActive = activeTool.type === 'image' && activeTool.value === item.file;
            el.className = `tool-btn ${isActive?'active':''}`;
            el.style.backgroundImage = `url('${item.file}')`;
            el.title = item.name;
            el.onclick = () => setActiveTool({ type: 'image', value: item.file });
            c.appendChild(el);
        });
    }

    function setActiveTool(tool) {
        activeTool = tool;
        renderToolsBar(); // Od≈õwie≈º ramki
    }

    // --- 3. INTERAKCJA Z PROJEKTEM ---

    // Oblicza kolor tekstu (czarny/bia≈Çy) na podstawie jasno≈õci t≈Ça dla optymalnego kontrastu
    function getContrastColor(hexColor) {
        // Je≈õli to data:image (tekstura), zwr√≥ƒá bia≈Çy z cieniem
        if (hexColor.startsWith('data:')) {
            return { fill: 'white', shadow: '0 0 3px rgba(0,0,0,0.8)' };
        }

        // Konwersja hex na RGB
        let r, g, b;
        if (hexColor.startsWith('#')) {
            const hex = hexColor.slice(1);
            if (hex.length === 3) {
                r = parseInt(hex[0] + hex[0], 16);
                g = parseInt(hex[1] + hex[1], 16);
                b = parseInt(hex[2] + hex[2], 16);
            } else {
                r = parseInt(hex.slice(0, 2), 16);
                g = parseInt(hex.slice(2, 4), 16);
                b = parseInt(hex.slice(4, 6), 16);
            }
        } else {
            // Fallback dla nieprawid≈Çowych kolor√≥w
            return { fill: 'white', shadow: '0 0 3px rgba(0,0,0,0.8)' };
        }

        // Oblicz luminancjƒô (WCAG formula)
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

        // Jasne t≈Ço ‚Üí czarny tekst, ciemne t≈Ço ‚Üí bia≈Çy tekst
        if (luminance > 0.5) {
            return { fill: 'black', shadow: '0 0 2px rgba(255,255,255,0.5)' };
        } else {
            return { fill: 'white', shadow: '0 0 2px rgba(0,0,0,0.5)' };
        }
    }

    // Sprawdza kolizjƒô z innymi panelami
    function checkPanelCollision(x, y, width, height, excludeIndex = -1) {
        for (let i = 0; i < panels.length; i++) {
            if (i === excludeIndex) continue;
            const p = panels[i];

            // Sprawd≈∫ czy prostokƒÖty siƒô nak≈ÇadajƒÖ
            if (!(x + width <= p.x || x >= p.x + p.width ||
                  y + height <= p.y || y >= p.y + p.height)) {
                return true; // Kolizja!
            }
        }
        return false; // Brak kolizji
    }

    // Silny snap do pustej przestrzeni - snap do najbli≈ºszej krawƒôdzi w lewo i w d√≥≈Ç
    function findBestSnapPosition(clickX, clickY, width, height) {
        // Znajd≈∫ najbli≈ºszƒÖ krawƒôd≈∫ w LEWO (dla X) i w D√ì≈Å (dla Y)

        let snapX = clickX;
        let snapY = clickY;

        // KROK 0: Inteligentny snap wertykalny - sprawd≈∫ czy istniejƒÖ panele "pod" kursorem (pionowa projekcja)
        let panelsBelow = panels.filter(p => {
            // Panel jest "pod" kursorem je≈õli:
            // 1. Jego zakres X zawiera clickX
            // 2. Jego g√≥rna krawƒôd≈∫ jest poni≈ºej lub na poziomie clickY
            return (p.x <= clickX && clickX <= p.x + p.width) &&
                   (p.y + p.height <= clickY);
        });

        if (panelsBelow.length > 0) {
            // Znajd≈∫ najbli≈ºszy panel w pionie (ten z najwiƒôkszym y + height)
            let closestPanel = panelsBelow.reduce((closest, p) => {
                return (p.y + p.height > closest.y + closest.height) ? p : closest;
            });

            // Snapuj do g√≥rnej krawƒôdzi tego panelu
            snapX = closestPanel.x;
            snapY = closestPanel.y + closestPanel.height;

            // Sprawd≈∫ kolizjƒô i dopasowanie
            if (!checkPanelCollision(snapX, snapY, width, height) &&
                checkPanelFits(snapX, snapY, width, height)) {
                return { x: snapX, y: snapY };
            }

            // Je≈õli jest kolizja, spr√≥buj przesunƒÖƒá w prawo
            const searchRadius = 50;
            for (let dx = 5; dx <= searchRadius; dx += 5) {
                const testX = snapX + dx;
                if (!checkPanelCollision(testX, snapY, width, height) &&
                    checkPanelFits(testX, snapY, width, height)) {
                    return { x: testX, y: snapY };
                }
            }

            // Je≈õli nie uda≈Ço siƒô znale≈∫ƒá miejsca, przejd≈∫ do standardowego algorytmu
        }

        // STANDARD SNAP: Je≈õli nie znaleziono panelu "pod" kursorem, u≈ºyj obecnego algorytmu
        // 1. SNAP X (w lewo) - znajd≈∫ najbli≈ºszƒÖ krawƒôd≈∫ po lewej stronie
        let leftEdges = [50]; // Lewa krawƒôd≈∫ obszaru (startX)

        // Dodaj LEWƒÑ i PRAWƒÑ krawƒôd≈∫ wszystkich paneli
        panels.forEach(p => {
            leftEdges.push(p.x);           // Lewa krawƒôd≈∫ panelu
            leftEdges.push(p.x + p.width); // Prawa krawƒôd≈∫ panelu
        });

        // Znajd≈∫ najbli≈ºszƒÖ krawƒôd≈∫ w lewo od klikniƒôcia
        let closestLeftEdge = 50; // Domy≈õlnie lewa krawƒôd≈∫ obszaru
        let minLeftDistance = Infinity;

        leftEdges.forEach(edge => {
            if (edge <= clickX) { // Tylko krawƒôdzie po lewej
                const distance = clickX - edge;
                if (distance < minLeftDistance) {
                    minLeftDistance = distance;
                    closestLeftEdge = edge;
                }
            }
        });

        snapX = closestLeftEdge;

        // 2. SNAP Y (w d√≥≈Ç) - znajd≈∫ najbli≈ºszƒÖ krawƒôd≈∫ poni≈ºej
        let bottomEdges = [0]; // Dolna krawƒôd≈∫ obszaru (floor)

        // Dodaj DOLNƒÑ i G√ìRNƒÑ krawƒôd≈∫ wszystkich paneli
        panels.forEach(p => {
            bottomEdges.push(p.y);             // Dolna krawƒôd≈∫ panelu
            bottomEdges.push(p.y + p.height);  // G√≥rna krawƒôd≈∫ panelu
        });

        // Znajd≈∫ najbli≈ºszƒÖ krawƒôd≈∫ w d√≥≈Ç od klikniƒôcia
        let closestBottomEdge = 0; // Domy≈õlnie dolna krawƒôd≈∫ obszaru
        let minBottomDistance = Infinity;

        bottomEdges.forEach(edge => {
            if (edge <= clickY) { // Tylko krawƒôdzie poni≈ºej
                const distance = clickY - edge;
                if (distance < minBottomDistance) {
                    minBottomDistance = distance;
                    closestBottomEdge = edge;
                }
            }
        });

        snapY = closestBottomEdge;

        // 3. Sprawd≈∫ czy po snapie nie ma kolizji i panel siƒô mie≈õci
        if (checkPanelCollision(snapX, snapY, width, height) ||
            !checkPanelFits(snapX, snapY, width, height)) {

            const searchRadius = 50;
            let minDistance = Infinity;
            let bestX = snapX;
            let bestY = snapY;

            // PRIORYTET 1: Spr√≥buj zachowaƒá snapY (przesuwaj tylko X w prawo)
            // To preferuje uk≈Çadanie NAD istniejƒÖcymi panelami
            for (let dx = 5; dx <= searchRadius; dx += 5) {
                const testX = snapX + dx;
                if (!checkPanelCollision(testX, snapY, width, height) &&
                    checkPanelFits(testX, snapY, width, height)) {
                    return { x: testX, y: snapY }; // Znaleziono! Zachowano Y
                }
            }

            // PRIORYTET 2: Szukaj w innych kierunkach z wagƒÖ preferujƒÖcƒÖ ma≈Çe zmiany Y
            // Waga: ma≈Çe zmiany Y sƒÖ 3x lepsze ni≈º ma≈Çe zmiany X
            for (let dy = 5; dy <= searchRadius; dy += 5) {
                for (let dx = -searchRadius; dx <= searchRadius; dx += 5) {
                    const testX = snapX + dx;
                    const testY = snapY + dy;

                    if (!checkPanelCollision(testX, testY, width, height) &&
                        checkPanelFits(testX, testY, width, height)) {
                        // Waga: ma≈Çe zmiany Y sƒÖ bardziej preferowane (mno≈ºnik 3)
                        const distance = Math.sqrt(dx * dx + (dy * 3) * (dy * 3));
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestX = testX;
                            bestY = testY;
                        }
                    }
                }
            }

            return { x: bestX, y: bestY };
        }

        return { x: snapX, y: snapY };
    }

    // Sprawdza wysoko≈õƒá obszaru roboczego w danym punkcie X
    function getHeightAtPosition(x) {
        if (wallData.segments.length === 0) return 0;

        let currentX = 50;
        let currentHeight = 0;

        for (let i = 0; i < wallData.segments.length; i++) {
            const seg = wallData.segments[i];
            const segStart = currentX;
            const segEnd = currentX + seg.width;

            if (x >= segStart && x < segEnd) {
                // X jest w tym segmencie - interpoluj wysoko≈õƒá
                const ratio = (x - segStart) / seg.width;
                return seg.startHeight + ratio * (seg.endHeight - seg.startHeight);
            }

            if (x >= segEnd && i === wallData.segments.length - 1) {
                // X jest za ostatnim segmentem
                return seg.endHeight;
            }

            currentX += seg.width;
        }

        return 0;
    }

    // Sprawdza czy panel mie≈õci siƒô w obszarze roboczym
    function checkPanelFits(x, y, width, height) {
        if (wallData.segments.length === 0) return true;

        // Sprawd≈∫ czy panel nie wychodzi poza szeroko≈õƒá obszaru
        let totalWidth = 50; // startX
        wallData.segments.forEach(s => totalWidth += s.width);

        if (x + width > totalWidth + 50) return false;

        // Sprawd≈∫ czy panel nie wychodzi ponad wysoko≈õƒá w ka≈ºdym punkcie
        const samples = 5; // Sprawd≈∫ w 5 punktach szeroko≈õci panelu
        for (let i = 0; i <= samples; i++) {
            const sampleX = x + (width * i / samples);
            const maxHeight = getHeightAtPosition(sampleX);
            if (y + height > maxHeight) return false;
        }

        return true;
    }

    // Znajduje nastƒôpnƒÖ mo≈ºliwƒÖ pozycjƒô dla panelu
    function findNextValidPosition(width, height) {
        if (wallData.segments.length === 0) {
            return { x: 50, y: 0, mode: 'horizontal', fits: false };
        }

        // Zacznij od pozycji bazowej
        let x = 50, y = 0;

        if (panels.length > 0) {
            const lastPanel = panels[panels.length - 1];

            if (layoutMode === 'horizontal') {
                x = lastPanel.x + lastPanel.width;
                y = 0;
            } else {
                x = lastPanel.x;
                y = lastPanel.y + lastPanel.height;
            }
        }

        // Sprawd≈∫ czy pasuje w bie≈ºƒÖcym trybie
        if (checkPanelFits(x, y, width, height)) {
            return { x, y, mode: layoutMode, fits: true };
        }

        // Je≈õli nie pasuje, spr√≥buj drugi tryb
        const altMode = layoutMode === 'horizontal' ? 'vertical' : 'horizontal';

        if (panels.length > 0) {
            const lastPanel = panels[panels.length - 1];

            if (altMode === 'horizontal') {
                x = lastPanel.x + lastPanel.width;
                y = 0;
            } else {
                x = lastPanel.x;
                y = lastPanel.y + lastPanel.height;
            }
        }

        if (checkPanelFits(x, y, width, height)) {
            return { x, y, mode: altMode, fits: true };
        }

        // Nic nie pasuje
        return { x, y, mode: layoutMode, fits: false };
    }

    function addPanel(width, height) {
        // Nowy panel otrzymuje styl z aktywnego narzƒôdzia (je≈õli to nie gumka)
        let style = { type: 'color', value: '#cccccc' }; // Default
        if (activeTool !== 'eraser') style = { ...activeTool };

        let x, y;

        // U≈ºyj pozycji z preview (je≈õli u≈ºytkownik kliknƒÖ≈Ç w obszar) lub auto pozycja
        if (previewPosition) {
            x = previewPosition.x;
            y = previewPosition.y;

            // Sprawd≈∫ kolizjƒô z innymi panelami (mo≈ºna dodaƒá panel czƒô≈õciowo poza obszarem, ale nie na innym panelu)
            if (checkPanelCollision(x, y, width, height)) {
                showProjectMessage('Panel koliduje z innym panelem! Kliknij w inne miejsce lub wybierz mniejszy panel.', 'error');
                return;
            }

            // Zresetuj preview po dodaniu
            previewPosition = null;
            previewLocked = false;
        } else {
            // Brak preview - u≈ºyj auto pozycji (sekwencyjne dodawanie)
            const nextPos = findNextValidPosition(width, height);

            if (!nextPos.fits) {
                showProjectMessage('Panel czƒô≈õciowo poza obszarem i zostanie uciƒôty', 'warning');
                // Pozw√≥l dodaƒá panel mimo ≈ºe czƒô≈õciowo poza obszarem
            }

            // Zaktualizuj tryb dla nastƒôpnego automatycznego dodawania
            if (nextPos.mode !== layoutMode) {
                layoutMode = nextPos.mode;
            }

            x = nextPos.x;
            y = nextPos.y;
        }

        panels.push({ width, height, x, y, style });

        // Zapamiƒôtaj rozmiar dla auto-preview
        lastUsedPanelSize = { width, height };

        draw();
        updateMappingUI();
    }

    function getSVGCoordinates(event) {
        const svg = document.querySelector('#svgWrapper svg');
        if (!svg) return null;

        const pt = svg.createSVGPoint();
        pt.x = event.clientX;
        pt.y = event.clientY;

        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
        return { x: svgP.x, y: svgP.y };
    }

    function onCanvasMouseMove(event) {
        if (!lastUsedPanelSize) {
            previewPosition = null;
            return;
        }

        // Je≈õli preview jest zamro≈ºony (po snapie), nie aktualizuj pozycji
        if (previewLocked) {
            return;
        }

        const coords = getSVGCoordinates(event);
        if (!coords) return;

        // Przelicz wsp√≥≈Çrzƒôdne z SVG (y od g√≥ry) na nasze (y od do≈Çu)
        // Znajd≈∫ floorY z obecnego obszaru
        if (wallData.segments.length === 0) return;

        let maxH = 0;
        wallData.segments.forEach(s => {
            maxH = Math.max(maxH, s.startHeight, s.endHeight);
        });
        const padY = 60;
        const floorY = maxH + padY * 2 - padY;

        // coords.y jest od g√≥ry SVG, musimy przeliczyƒá na y od do≈Çu
        const yFromBottom = floorY - coords.y;
        const x = coords.x;

        // Smart snap (tylko podglƒÖd, bez kolizji - pokazujemy gdzie bƒôdzie)
        previewPosition = { x, y: yFromBottom };
        draw();
    }

    function onCanvasClick(event) {
        // Sprawd≈∫ czy klikniƒôto w panel (je≈õli tak, niech onPanelClick to obs≈Çu≈ºy)
        if (event.target.closest('g[onclick]')) return;

        if (!lastUsedPanelSize) return;

        const coords = getSVGCoordinates(event);
        if (!coords) return;

        // Przelicz wsp√≥≈Çrzƒôdne z SVG (y od g√≥ry) na nasze (y od do≈Çu)
        if (wallData.segments.length === 0) return;

        let maxH = 0;
        wallData.segments.forEach(s => {
            maxH = Math.max(maxH, s.startHeight, s.endHeight);
        });
        const padY = 60;
        const floorY = maxH + padY * 2 - padY;

        const yFromBottom = floorY - coords.y - lastUsedPanelSize.height; // Pozycja lewego dolnego rogu
        const x = coords.x;

        // Smart snap do pustej przestrzeni
        const snapped = findBestSnapPosition(x, yFromBottom, lastUsedPanelSize.width, lastUsedPanelSize.height);
        previewPosition = snapped; // Ustaw preview w snappowanym miejscu
        previewLocked = true; // Zamro≈∫ preview po snapie
        draw();
    }

    function onPanelClick(index) {
        if (activeTool === 'eraser') {
            panels.splice(index, 1); // USU≈É
        } else {
            panels[index].style = { ...activeTool }; // MALUJ
        }
        draw();
        updateMappingUI();
    }

    function undoPanel() { panels.pop(); draw(); updateMappingUI(); }

    function clearWorkspace() {
        if (panels.length === 0) {
            showProjectMessage('Obszar roboczy jest ju≈º pusty!', 'info');
            return;
        }
        showProjectConfirm(`Czy na pewno chcesz usunƒÖƒá wszystkie panele (${panels.length} szt)?`, () => {
            panels = [];
            draw();
            updateMappingUI();
        });
    }

    // --- 4. ZAPIS (FIFO) ---
    function saveCurrentLayout() {
        let saves = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        saves.unshift({
            id: Date.now(),
            date: new Date().toLocaleTimeString(),
            wall: wallData,
            panels: panels,
            variants: variants,
            mapping: styleMapping,
            mode: layoutMode
        });
        if(saves.length > 5) saves.pop();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(saves));
        renderSaves();
    }

    function renderSaves() {
        const c = document.getElementById('savesContainer');
        c.innerHTML = '';
        const saves = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        if(saves.length===0) c.innerHTML='<div style="color:#999; font-size:0.8em;">Pusto</div>';

        saves.forEach(s => {
            const d = document.createElement('div'); d.className='save-slot';
            d.innerHTML = `<span>${s.date} (${s.panels.length} el.)</span>
                <button class="btn-secondary" style="padding:2px 5px; font-size:0.8em;" onclick="loadSave(${s.id})">Wczytaj</button>`;
            c.appendChild(d);
        });
    }

    function loadSave(id) {
        const s = JSON.parse(localStorage.getItem(STORAGE_KEY)).find(x=>x.id===id);
        if(s && confirm("Wczytaƒá projekt?")) {
            wallData = s.wall;
            panels = s.panels;
            variants = s.variants || variants;
            styleMapping = s.mapping || {};
            layoutMode = s.mode || 'horizontal';

            draw();
            renderSegmentsList();
            renderVariantConfig();
            renderTopBar();
            updateMappingUI();
        }
    }

    // --- 5. LOGIKA OBSZARU ROBOCZEGO ---
    function loadPresetWorkspace() {
        wallData.segments = [
            {width: 60, startHeight: 140, endHeight: 140},
            {width: 200, startHeight: 140, endHeight: 140},
            {width: 60, startHeight: 140, endHeight: 140},
            {width: 100, startHeight: 140, endHeight: 80}
        ];
        renderSegmentsList();
        draw();
        updateMappingUI();
    }

    function addSegment() {
        const w = parseFloat(document.getElementById('segWidth').value);
        const sh = parseFloat(document.getElementById('segStartHeight').value);
        const eh = parseFloat(document.getElementById('segEndHeight').value);

        // Walidacja: sprawd≈∫ czy wszystkie pola sƒÖ wype≈Çnione
        if (!w || !sh || !eh || w <= 0 || sh <= 0 || eh <= 0) {
            alert('Wype≈Çnij wszystkie pola (szeroko≈õƒá, wysoko≈õƒá poczƒÖtkowa i ko≈Ñcowa) warto≈õciami wiƒôkszymi od 0');
            return;
        }

        wallData.segments.push({width: w, startHeight: sh, endHeight: eh});
        document.getElementById('segWidth').value = '';
        document.getElementById('segEndHeight').value = '';

        // Auto-wype≈Çnianie: przepisz wysoko≈õƒá ko≈ÑcowƒÖ do pola poczƒÖtkowej
        document.getElementById('segStartHeight').value = eh;

        renderSegmentsList();
        draw();
        updateMappingUI();
    }

    function removeSegment(i) {
        wallData.segments.splice(i, 1);
        renderSegmentsList();
        draw();
        updateMappingUI();
    }

    function resetWall() {
        if(confirm("Resetowaƒá obszar roboczy?")) {
            wallData.segments = [];
            document.getElementById('segStartHeight').value = '';
            document.getElementById('segEndHeight').value = '';
            renderSegmentsList();
            draw();
            updateMappingUI();
        }
    }

    function renderSegmentsList() {
        const c = document.getElementById('segmentsContainer');
        c.innerHTML = '';

        wallData.segments.forEach((s, i) => {
            // Okre≈õl ikonƒô kszta≈Çtu: prostokƒÖt (‚ñ≠) lub trapez (‚è¢)
            const shapeIcon = s.startHeight === s.endHeight ? '‚ñ≠' : '‚è¢';

            c.innerHTML += `<div class="segment-row">
                <span><span class="segment-icon" title="${s.startHeight === s.endHeight ? 'ProstokƒÖt' : 'Trapez'}">${shapeIcon}</span>${i+1}. <b>${s.width}</b>cm | ${s.startHeight}cm ‚Üí ${s.endHeight}cm</span>
                <button class="btn-x" onclick="removeSegment(${i})">X</button>
            </div>`;
        });
    }

    // --- 6. WYCENA & MAPOWANIE ---
    function updateMappingUI() {
        const used = [...new Set(panels.map(p=>p.style.value))];
        const c = document.getElementById('mappingContainer'); c.innerHTML='';
        if(used.length===0) { c.innerHTML='<div style="color:#999; font-size:0.8em;">Brak paneli</div>'; recalculatePrice(); return; }

        used.forEach(val => {
            const row = document.createElement('div'); row.className='mapping-item';
            const sw = document.createElement('div'); sw.className='map-swatch';
            if(val.includes('data:image')) { sw.style.backgroundImage=`url('${val}')`; sw.style.backgroundSize='cover'; }
            else sw.style.backgroundColor=val;

            const sel = document.createElement('select'); sel.className='map-select';
            sel.onchange = (e) => { styleMapping[val]=e.target.value; recalculatePrice(); };

            ['Standard','Premium','Exclusive'].forEach(grp => {
                const g = document.createElement('optgroup'); g.label=grp;
                Collections[grp].forEach(col => {
                    const o = document.createElement('option'); o.value=col; o.text=col;
                    if(styleMapping[val]===col) o.selected=true;
                    g.appendChild(o);
                });
                sel.appendChild(g);
            });
            if(!styleMapping[val]) { styleMapping[val]=Collections.Standard[0]; sel.value=Collections.Standard[0]; }

            row.appendChild(sw); row.appendChild(sel); c.appendChild(row);
        });
        recalculatePrice();
    }

    function recalculatePrice() {
        const opts = {
            foam: document.getElementById('optFoam').checked,
            velcro: document.getElementById('optVelcro').checked,
            glue: parseInt(document.getElementById('optGlue').value)||0,
            outlets: parseInt(document.getElementById('optOutlets')?.value || 0),
            shipping: document.getElementById('optShipping').checked
        };

        if (panels.length === 0) {
            document.getElementById('totalPriceDisplay').innerText = "0.00 z≈Ç";
            document.getElementById('priceDetails').innerHTML = '<div style="color:#999; font-size:0.9em;">Brak paneli</div>';
            return;
        }

        // GRUPOWANIE PANELI (rozmiar √ó tkanina)
        const groups = {};
        let totalArea = 0;

        panels.forEach(p => {
            const col = styleMapping[p.style.value] || 'DIANA';
            let category = 'Standard';
            if (Collections.Premium.includes(col)) category = 'Premium';
            if (Collections.Exclusive.includes(col)) category = 'Exclusive';

            const key = `${p.width}x${p.height}`;
            const groupKey = `${key}|${col}|${category}`;

            if (!groups[groupKey]) {
                groups[groupKey] = {
                    size: `${p.width}√ó${p.height} cm`,
                    fabric: col,
                    category: category,
                    count: 0,
                    unitPrice: 0,
                    area: 0
                };
            }

            // Pobierz cenƒô jednostkowƒÖ
            let base = 0;
            if (category === 'Standard' && RozmStandard[key]) {
                base = RozmStandard[key];
            } else if (category === 'Premium' && RozmPremium[key]) {
                base = RozmPremium[key];
            } else if (category === 'Exclusive' && RozmExclusive[key]) {
                base = RozmExclusive[key];
            } else {
                base = ((p.width * p.height) / 10000) * 300;
            }

            groups[groupKey].count++;
            groups[groupKey].unitPrice = base;
            groups[groupKey].area += (p.width * p.height) / 10000;
            totalArea += (p.width * p.height) / 10000;
        });

        // GENEROWANIE LISTY MATERIA≈Å√ìW
        let html = '<div style="font-size:0.85em; line-height:1.6;">';

        // === PANELE ===
        html += '<div style="font-weight:bold; margin-bottom:8px; padding-bottom:4px; border-bottom:2px solid #28a745; color:#28a745;">‚ïê‚ïê‚ïê PANELE ‚ïê‚ïê‚ïê</div>';
        let panelsTotal = 0;

        Object.values(groups).forEach(g => {
            const subtotal = g.count * g.unitPrice;
            panelsTotal += subtotal;
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                <span style="font-weight:500;">${g.size}</span>
                <span style="color:#666;">(${g.fabric})</span> -
                ${g.count} szt √ó ${g.unitPrice.toFixed(2)} z≈Ç =
                <span style="font-weight:bold;">${subtotal.toFixed(2)} z≈Ç</span>
            </div>`;
        });

        // === DODATKI ===
        html += '<div style="font-weight:bold; margin:12px 0 8px 0; padding-bottom:4px; border-bottom:2px solid #ff9800; color:#ff9800;">‚ïê‚ïê‚ïê DODATKI ‚ïê‚ïê‚ïê</div>';
        let extrasTotal = 0;

        // Pianka
        if (opts.foam) {
            let foamCost = 0;
            let foamDetails = [];
            panels.forEach(p => {
                const m2 = (p.width * p.height) / 10000;
                let cost = 0;
                if (m2 < 0.4) cost = 6;
                else if (m2 < 0.9) cost = 15;
                else if (m2 < 1.5) cost = 30;
                else if (m2 < 2.0) cost = 60;
                else cost = 100;
                foamCost += cost;
            });
            extrasTotal += foamCost;
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                ‚òë Podw√≥jna pianka - ${panels.length} paneli (6-100 z≈Ç) =
                <span style="font-weight:bold;">${foamCost.toFixed(2)} z≈Ç</span>
            </div>`;
        }

        // Rzep
        if (opts.velcro) {
            let velcroCost = 0;
            panels.forEach(p => {
                const m2 = (p.width * p.height) / 10000;
                let cost = 0;
                if (m2 < 0.4) cost = 8;
                else if (m2 < 0.9) cost = 20;
                else if (m2 < 1.5) cost = 40;
                else if (m2 < 2.0) cost = 70;
                else cost = 120;
                velcroCost += cost;
            });
            extrasTotal += velcroCost;
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                ‚òë Rzep monta≈ºowy - ${panels.length} paneli (8-120 z≈Ç) =
                <span style="font-weight:bold;">${velcroCost.toFixed(2)} z≈Ç</span>
            </div>`;
        }

        // Otwory na kontakt
        if (opts.outlets > 0) {
            const outletsCost = opts.outlets * 39;
            extrasTotal += outletsCost;
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                Otwory na kontakt - ${opts.outlets} szt √ó 39 z≈Ç =
                <span style="font-weight:bold;">${outletsCost.toFixed(2)} z≈Ç</span>
            </div>`;
        }

        // Klej
        if (opts.glue > 0) {
            const glueCost = opts.glue * 36;
            extrasTotal += glueCost;
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                Klej monta≈ºowy - ${opts.glue} szt √ó 36 z≈Ç =
                <span style="font-weight:bold;">${glueCost.toFixed(2)} z≈Ç</span>
            </div>`;
        }

        if (extrasTotal === 0) {
            html += '<div style="margin-bottom:4px; padding-left:8px; color:#999;">Brak wybranych dodatk√≥w</div>';
        }

        // === LOGISTYKA ===
        html += '<div style="font-weight:bold; margin:12px 0 8px 0; padding-bottom:4px; border-bottom:2px solid #2196f3; color:#2196f3;">‚ïê‚ïê‚ïê LOGISTYKA ‚ïê‚ïê‚ïê</div>';
        let shippingCost = 0;
        if (opts.shipping) {
            shippingCost = 39; // Uproszczona wersja, mo≈ºna rozszerzyƒá o kalkulacjƒô gabarytu
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                ‚òë Wysy≈Çka = <span style="font-weight:bold;">${shippingCost.toFixed(2)} z≈Ç</span>
            </div>`;
        } else {
            html += '<div style="margin-bottom:4px; padding-left:8px; color:#999;">Brak wysy≈Çki</div>';
        }

        // === PODSUMOWANIE ===
        html += '<div style="font-weight:bold; margin:12px 0 8px 0; padding-bottom:4px; border-bottom:2px solid #333; color:#333;">‚ïê‚ïê‚ïê PODSUMOWANIE ‚ïê‚ïê‚ïê</div>';
        html += `<div style="margin-bottom:4px; padding-left:8px;">
            Suma paneli: <span style="font-weight:bold;">${panelsTotal.toFixed(2)} z≈Ç</span>
            <span style="color:#666;">(${panels.length} szt, ${totalArea.toFixed(2)} m¬≤)</span>
        </div>`;
        html += `<div style="margin-bottom:4px; padding-left:8px;">
            Suma dodatk√≥w: <span style="font-weight:bold;">${extrasTotal.toFixed(2)} z≈Ç</span>
        </div>`;
        html += `<div style="margin-bottom:4px; padding-left:8px;">
            Wysy≈Çka: <span style="font-weight:bold;">${shippingCost.toFixed(2)} z≈Ç</span>
        </div>`;
        html += '<div style="margin-top:8px; padding-top:8px; border-top:2px solid #333;"></div>';

        const grandTotal = panelsTotal + extrasTotal + shippingCost;
        html += '</div>';

        document.getElementById('totalPriceDisplay').innerText = grandTotal.toFixed(2) + " z≈Ç";
        document.getElementById('priceDetails').innerHTML = html;
    }

    // --- 7. WIZUALIZACJA ---
    function draw() {
        const svg = document.getElementById('svgWrapper');

        if (wallData.segments.length === 0) {
            // Brak segment√≥w - poka≈º pustƒÖ przestrze≈Ñ
            svg.innerHTML = `<svg width="300px" viewBox="0 0 300 200">
                <text x="150" y="100" text-anchor="middle" fill="#999" font-size="14">
                    Dodaj segmenty obszaru
                </text>
            </svg>`;
            return;
        }

        let totalW = 0, maxH = 0;
        wallData.segments.forEach(s => {
            totalW += s.width;
            maxH = Math.max(maxH, s.startHeight, s.endHeight);
        });

        const padX = 50, padY = 60;
        const W = totalW + padX * 2, H = maxH + padY * 2;
        const startX = padX, floorY = H - padY;

        // Budowanie ≈õcie≈ºki obszaru roboczego
        let cx = startX;
        let d = `M ${cx} ${floorY}`;

        // Linia g√≥rna (od lewej do prawej)
        wallData.segments.forEach(s => {
            d += ` L ${cx} ${floorY - s.startHeight}`;
            cx += s.width;
            d += ` L ${cx} ${floorY - s.endHeight}`;
        });

        // Zamkniƒôcie ≈õcie≈ºki (prawa krawƒôd≈∫ w d√≥≈Ç, linia dolna)
        d += ` L ${cx} ${floorY} Z`;

        let defs = `<clipPath id="wc"><path d="${d}"/></clipPath>`;
        const uTex = [...new Set(panels.filter(p=>p.style.type==='image').map(p=>p.style.value))];
        uTex.forEach((src,i)=> defs+=`<pattern id="pt${i}" patternUnits="userSpaceOnUse" width="50" height="50"><image href="${src}" x="0" y="0" width="50" height="50" preserveAspectRatio="xMidYMid slice"/></pattern>`);

        const pSvg = panels.map((p,i)=>{
            const fill = p.style.type==='color' ? p.style.value : `url(#pt${uTex.indexOf(p.style.value)})`;
            const cls = activeTool==='eraser' ? 'panel-rect delete-mode' : 'panel-rect';

            // Pozycja panelu (x,y od lewego dolnego rogu)
            const panelX = p.x;
            const panelY = floorY - p.y - p.height;

            // Sprawd≈∫ czy panel wystaje poza obszar
            const fits = checkPanelFits(p.x, p.y, p.width, p.height);

            // Wymiary WEWNƒÑTRZ panelu
            // Szeroko≈õƒá - poziomo na dole
            const widthTextY = panelY + p.height - 8;
            // Wysoko≈õƒá - pionowo (obr√≥cona 90¬∞) po prawej stronie
            const heightTextX = panelX + p.width - 8;
            const heightTextY = panelY + p.height/2;

            // Automatyczny kontrast tekstu na podstawie koloru t≈Ça
            const textColor = getContrastColor(p.style.value);

            return `<g onclick="onPanelClick(${i})">
                ${!fits ? `<rect x="${panelX}" y="${panelY}" width="${p.width}" height="${p.height}" fill="${fill}" opacity="0.3" stroke="#999" stroke-width="2" stroke-dasharray="5,5" pointer-events="none"/>` : ''}
                <rect x="${panelX}" y="${panelY}" width="${p.width}" height="${p.height}" fill="${fill}" ${!fits ? 'clip-path="url(#wc)"' : ''} class="${cls}"/>
                <text x="${panelX + p.width/2}" y="${widthTextY}" text-anchor="middle" class="dim-text-panel" fill="${textColor.fill}" style="text-shadow: ${textColor.shadow}">${p.width}</text>
                <text x="${heightTextX}" y="${heightTextY}" text-anchor="middle" class="dim-text-panel" fill="${textColor.fill}" style="text-shadow: ${textColor.shadow}" transform="rotate(-90 ${heightTextX} ${heightTextY})">${p.height}</text>
                <line x1="${panelX}" y1="${panelY}" x2="${panelX}" y2="${panelY + p.height}" stroke="rgba(0,0,0,0.15)" stroke-width="1"/>
                <line x1="${panelX + p.width}" y1="${panelY}" x2="${panelX + p.width}" y2="${panelY + p.height}" stroke="rgba(0,0,0,0.15)" stroke-width="1"/>
            </g>`;
        }).join('');

        // Preview nastƒôpnego panelu (z pozycji myszy lub auto)
        let previewSVG = '';
        const previewSize = selectedPanelSize || lastUsedPanelSize; // Hover lub ostatnio u≈ºyty

        if (previewSize) {
            let prevX, prevY;

            // U≈ºyj pozycji z previewPosition (ju≈º snappowanej) lub znajd≈∫ nastƒôpnƒÖ wolnƒÖ
            if (previewPosition) {
                prevX = previewPosition.x;
                prevY = floorY - previewPosition.y - previewSize.height;
            } else {
                // Fallback: znajd≈∫ nastƒôpnƒÖ pozycjƒô automatycznie
                const nextPos = findNextValidPosition(previewSize.width, previewSize.height);
                if (!nextPos.fits) return; // Brak miejsca

                prevX = nextPos.x;
                prevY = floorY - nextPos.y - previewSize.height;
            }

            // Sprawd≈∫ czy panel mie≈õci siƒô (dla kolorowania)
            const yFromBottom = floorY - prevY - previewSize.height;
            const fits = checkPanelFits(prevX, yFromBottom, previewSize.width, previewSize.height);
            const hasCollision = checkPanelCollision(prevX, yFromBottom, previewSize.width, previewSize.height);

            // Kolor preview: czerwony (kolizja), ≈º√≥≈Çty (poza obszarem), zielony (hover OK), niebieski (auto-preview OK)
            const isHover = selectedPanelSize !== null;
            let strokeColor, fillColor;
            if (hasCollision) {
                // üî¥ Czerwony - kolizja z innym panelem (BLOKADA)
                strokeColor = '#dc3545';
                fillColor = 'rgba(220, 53, 69, 0.15)';
            } else if (!fits) {
                // üü° ≈ª√≥≈Çty - czƒô≈õciowo poza obszarem (OSTRZE≈ªENIE - mo≈ºna dodaƒá)
                strokeColor = '#ffc107';
                fillColor = 'rgba(255, 193, 7, 0.15)';
            } else if (isHover) {
                // üü¢ Zielony - hover, wszystko OK
                strokeColor = '#28a745';
                fillColor = 'rgba(40, 167, 69, 0.2)';
            } else {
                // üîµ Niebieski - auto-preview, wszystko OK
                strokeColor = '#007bff';
                fillColor = 'rgba(0, 123, 255, 0.15)';
            }

            // Prze≈∫roczysty prostokƒÖt
            previewSVG += `<rect x="${prevX}" y="${prevY}" width="${previewSize.width}" height="${previewSize.height}"
                fill="${fillColor}" stroke="${strokeColor}" stroke-width="2" stroke-dasharray="5,5" pointer-events="none"/>`;

            // Strza≈Çka ‚Üô w lewym dolnym rogu (wewnƒÖtrz preview)
            const arrowX = prevX + 15; // 15px od lewej krawƒôdzi
            const arrowY = prevY + previewSize.height - 15; // 15px od dolnej krawƒôdzi
            const arrowSize = 12;

            previewSVG += `<text x="${arrowX}" y="${arrowY}" font-size="20" fill="${strokeColor}" font-weight="bold" pointer-events="none">‚Üô</text>`;
        }

        // Wymiarowanie segment√≥w (wysoko≈õci)
        let dimensionsSVG = '';
        let segX = startX;
        wallData.segments.forEach((s, idx) => {
            const topYStart = floorY - s.startHeight;
            const topYEnd = floorY - s.endHeight;

            // Linia wymiarowa na poczƒÖtku segmentu
            dimensionsSVG += `<line x1="${segX}" y1="${floorY}" x2="${segX}" y2="${topYStart - 10}" class="dim-line" stroke="#888" />`;
            dimensionsSVG += `<text x="${segX + 5}" y="${topYStart - 15}" text-anchor="start" class="dim-text-external" font-weight="bold">${s.startHeight}</text>`;

            // Wymiar szeroko≈õci segmentu (na dole)
            const segMidX = segX + s.width / 2;
            const dimY = floorY + 30;
            dimensionsSVG += `<line x1="${segX}" y1="${dimY}" x2="${segX + s.width}" y2="${dimY}" stroke="#444" stroke-width="1" />`;
            dimensionsSVG += `<line x1="${segX}" y1="${dimY-5}" x2="${segX}" y2="${dimY+5}" stroke="#444" stroke-width="1" />`;
            dimensionsSVG += `<line x1="${segX + s.width}" y1="${dimY-5}" x2="${segX + s.width}" y2="${dimY+5}" stroke="#444" stroke-width="1" />`;
            dimensionsSVG += `<text x="${segMidX}" y="${dimY + 15}" text-anchor="middle" class="dim-text-external" font-size="12" font-weight="bold">${s.width}</text>`;

            segX += s.width;

            // Linia wymiarowa na ko≈Ñcu ostatniego segmentu
            if (idx === wallData.segments.length - 1) {
                dimensionsSVG += `<line x1="${segX}" y1="${floorY}" x2="${segX}" y2="${topYEnd - 10}" class="dim-line" stroke="#888" />`;
                dimensionsSVG += `<text x="${segX - 5}" y="${topYEnd - 15}" text-anchor="end" class="dim-text-external" font-weight="bold">${s.endHeight}</text>`;
            }
        });

        svg.innerHTML = `<svg width="${W*zoomLevel}px" viewBox="0 0 ${W} ${H}">
            <defs>${defs}</defs>
            <path d="${d}" class="wall-bg"/>
            ${pSvg}
            ${previewSVG}
            <path d="${d}" fill="none" stroke="#555" stroke-width="2"/>
            ${dimensionsSVG}
        </svg>`;
    }

    function changeZoom(d) {
        zoomLevel = Math.max(0.2, Math.min(3.0, zoomLevel + d));
        document.getElementById('zoomLabel').innerText = Math.round(zoomLevel*100)+'%';
        draw();
    }
</script>

</body>
</html>
