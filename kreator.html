<!-- kreator.html v0.033 FAZA 2: Simplified Touch Gestures (DRAG=PAN, zoom tylko przyciski) -->
<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Kreator Paneli (Widok 2D + Top)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Readex+Pro:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ===== CSS VARIABLES ===== */
        :root {
            /* Dark Theme Colors */
            --color-bg-primary: #0f172a;
            --color-bg-gradient-from: #1e293b;
            --color-bg-gradient-via: #7c3aed;
            --color-bg-gradient-to: #1e293b;

            --color-surface: rgba(30, 41, 59, 0.9);
            --color-surface-hover: rgba(30, 41, 59, 0.95);
            --color-surface-border: rgba(148, 163, 184, 0.2);

            --color-text-primary: #f1f5f9;
            --color-text-secondary: #94a3b8;
            --color-text-muted: #64748b;

            /* Gradient Accents */
            --gradient-primary: linear-gradient(to right, #06b6d4, #a855f7, #ec4899);
            --gradient-glow: linear-gradient(to right, #06b6d4, #8b5cf6);
            --gradient-text: linear-gradient(to right, #06b6d4, #a78bfa, #f472b6);

            /* App Accent - Kreator (purple-pink mix) */
            --color-accent: #a855f7;
            --color-accent-rgb: 168, 85, 247;
            --color-accent-secondary: #ec4899;
            --color-success: #22c55e;
            --color-warning: #f59e0b;
            --color-danger: #ef4444;

            /* Spacing */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --spacing-2xl: 3rem;

            /* Mobile Spacing (overridden in media queries) */
            --spacing-mobile-xs: 0.25rem;
            --spacing-mobile-sm: 0.375rem;
            --spacing-mobile-md: 0.75rem;
            --spacing-mobile-lg: 1rem;
            --spacing-mobile-xl: 1.25rem;

            /* Border Radius */
            --radius-sm: 8px;
            --radius-base: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            --radius-2xl: 32px;

            /* Effects */
            --blur-sm: 8px;
            --blur-base: 12px;
            --blur-lg: 24px;
            --blur-xl: 40px;

            /* Shadows */
            --shadow-glow: 0 0 20px rgba(168, 85, 247, 0.4);
            --shadow-glow-lg: 0 0 40px rgba(168, 85, 247, 0.6);
            --shadow-card: 0 4px 12px rgba(0, 0, 0, 0.3);
            --shadow-card-hover: 0 8px 24px rgba(0, 0, 0, 0.4);

            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-base: 0.3s ease;
            --transition-slow: 0.5s ease-out;

            /* Font */
            --font-primary: 'Readex Pro', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        /* ===== BASE STYLES ===== */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: var(--font-primary);
            background: linear-gradient(to bottom right,
                var(--color-bg-gradient-from),
                var(--color-bg-gradient-via),
                var(--color-bg-gradient-to));
            color: var(--color-text-primary);
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
            position: relative;
            overflow-x: hidden;
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
        }

        /* ===== ANIMATIONS ===== */
        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            25% { transform: translate(50px, -50px) scale(1.1); }
            50% { transform: translate(-30px, 30px) scale(0.95); }
            75% { transform: translate(30px, 50px) scale(1.05); }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes shimmer {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        @keyframes glow-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(var(--color-accent-rgb), 0.4); }
            50% { box-shadow: 0 0 40px rgba(var(--color-accent-rgb), 0.8); }
        }

        .fade-in-up {
            opacity: 0;
            animation: fadeInUp 0.8s ease-out forwards;
        }

        .delay-100 { animation-delay: 0.1s; }
        .delay-200 { animation-delay: 0.2s; }
        .delay-300 { animation-delay: 0.3s; }

        /* ===== ANIMATED BACKGROUND ===== */
        .animated-bg {
            position: fixed;
            inset: 0;
            overflow: hidden;
            pointer-events: none;
            z-index: 0;
        }

        .animated-bg__blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(var(--blur-xl));
            opacity: 0.5;
            animation: float 20s ease-in-out infinite;
        }

        .animated-bg__blob:nth-child(1) {
            width: 300px;
            height: 300px;
            background: rgba(139, 92, 246, 0.3);
            top: -150px;
            right: -150px;
        }

        .animated-bg__blob:nth-child(2) {
            width: 400px;
            height: 400px;
            background: rgba(6, 182, 212, 0.3);
            bottom: -200px;
            left: -200px;
            animation-delay: 5s;
        }

        .animated-bg__blob:nth-child(3) {
            width: 350px;
            height: 350px;
            background: rgba(236, 72, 153, 0.3);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation-delay: 10s;
        }

        /* ===== LAYOUT ===== */
        .layout {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: var(--spacing-xl);
            height: 95vh;
            position: relative;
            z-index: 1;
        }

        /* ===== CONTROLS (LEFT COLUMN) ===== */
        .controls {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
            height: 100%;
            overflow-y: auto;
            padding-right: var(--spacing-sm);
            scrollbar-width: thin;
            scrollbar-color: rgba(168, 85, 247, 0.3) rgba(30, 41, 59, 0.3);
        }

        .controls::-webkit-scrollbar {
            width: 8px;
        }

        .controls::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.3);
            border-radius: 4px;
        }

        .controls::-webkit-scrollbar-thumb {
            background: rgba(168, 85, 247, 0.3);
            border-radius: 4px;
        }

        .controls::-webkit-scrollbar-thumb:hover {
            background: rgba(168, 85, 247, 0.5);
        }

        /* ===== CARDS ===== */
        .card {
            background: var(--color-surface);
            backdrop-filter: blur(var(--blur-base));
            -webkit-backdrop-filter: blur(var(--blur-base));
            border: 1px solid var(--color-surface-border);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-card);
            transition: all var(--transition-base);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: var(--gradient-primary);
            border-radius: var(--radius-xl);
            opacity: 0;
            transition: opacity var(--transition-base);
            z-index: -1;
            filter: blur(10px);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-card-hover);
            border-color: rgba(var(--color-accent-rgb), 0.3);
        }

        .card:hover::before {
            opacity: 0.3;
        }

        /* ===== TYPOGRAPHY ===== */
        h3 {
            margin: 0 0 var(--spacing-lg) 0;
            font-size: 1.1em;
            font-weight: 600;
            color: var(--color-text-primary);
            padding-bottom: var(--spacing-sm);
            border-bottom: 2px solid rgba(148, 163, 184, 0.2);
        }

        label {
            display: block;
            font-size: 0.85em;
            font-weight: 500;
            color: var(--color-text-secondary);
            margin-bottom: var(--spacing-xs);
        }

        /* ===== FORM ELEMENTS ===== */
        input[type="number"],
        input[type="text"],
        select {
            width: 100%;
            padding: var(--spacing-md) var(--spacing-lg);
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid var(--color-surface-border);
            border-radius: var(--radius-base);
            color: var(--color-text-primary);
            font-family: var(--font-primary);
            font-size: 0.9em;
            transition: all var(--transition-base);
            backdrop-filter: blur(var(--blur-sm));
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: var(--color-accent);
            box-shadow: 0 0 0 3px rgba(var(--color-accent-rgb), 0.2);
            background: rgba(15, 23, 42, 0.8);
        }

        input[type="number"]::placeholder,
        input[type="text"]::placeholder {
            color: var(--color-text-muted);
        }

        input[type="checkbox"] {
            accent-color: var(--color-accent);
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* ===== BUTTONS ===== */
        button {
            cursor: pointer;
            transition: all var(--transition-base);
            font-family: var(--font-primary);
            border: none;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        button:hover::before {
            transform: translateX(100%);
        }

        .btn-secondary {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(var(--blur-sm));
            border: 1px solid var(--color-surface-border);
            color: var(--color-text-primary);
            padding: 8px 16px;
            border-radius: var(--radius-base);
            font-size: 0.9em;
        }

        .btn-secondary:hover {
            background: rgba(30, 41, 59, 0.95);
            border-color: rgba(var(--color-accent-rgb), 0.5);
            transform: scale(1.05);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--color-danger), rgba(239, 68, 68, 0.7));
            color: white;
            border: 1px solid rgba(239, 68, 68, 0.3);
            padding: var(--spacing-md);
            border-radius: var(--radius-base);
            width: 100%;
            margin-top: var(--spacing-md);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }

        .btn-danger:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 25px rgba(239, 68, 68, 0.5);
        }

        .btn-add-segment {
            width: 100%;
            background: linear-gradient(135deg, var(--color-accent), rgba(var(--color-accent-rgb), 0.7));
            color: white;
            padding: var(--spacing-md);
            border-radius: var(--radius-base);
            margin-top: var(--spacing-sm);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(var(--color-accent-rgb), 0.3);
        }

        .btn-add-segment:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 25px rgba(var(--color-accent-rgb), 0.5);
        }

        /* ===== SEGMENTS LIST ===== */
        .segment-row {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: var(--spacing-sm);
            align-items: center;
            padding: var(--spacing-md);
            background: rgba(15, 23, 42, 0.4);
            border: 1px solid rgba(148, 163, 184, 0.15);
            border-radius: var(--radius-base);
            margin-bottom: var(--spacing-xs);
            font-size: 0.9em;
            transition: all var(--transition-base);
        }

        .segment-row:hover {
            background: rgba(15, 23, 42, 0.6);
            border-color: rgba(var(--color-accent-rgb), 0.3);
        }

        .segment-icon {
            font-size: 1.2em;
            color: var(--color-accent);
        }

        .segment-info {
            flex: 1;
            color: var(--color-text-primary);
        }

        .segment-angle-input {
            width: 45px;
            padding: 4px;
            font-size: 0.85em;
            border: 1px solid var(--color-surface-border);
            border-radius: var(--radius-sm);
            margin-left: 5px;
            text-align: center;
            background: rgba(15, 23, 42, 0.5);
            color: var(--color-text-primary);
        }

        .angle-btn {
            padding: 4px 10px;
            font-size: 0.8em;
            border: 1px solid var(--color-surface-border);
            background: rgba(30, 41, 59, 0.6);
            border-radius: var(--radius-sm);
            cursor: pointer;
            color: var(--color-text-primary);
            font-weight: 600;
            margin-left: 2px;
            transition: all var(--transition-fast);
        }

        .angle-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: var(--color-accent);
            color: var(--color-accent);
        }

        .angle-btn:active {
            transform: scale(0.95);
        }

        .master-radio {
            margin-right: 5px;
            cursor: pointer;
            accent-color: var(--color-accent);
        }

        .btn-x {
            padding: 4px 10px;
            font-size: 0.8em;
            color: var(--color-danger);
            border: 1px solid rgba(239, 68, 68, 0.5);
            background: rgba(239, 68, 68, 0.1);
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }

        .btn-x:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: var(--color-danger);
        }

        /* ===== VARIANTS ===== */
        .variant-config-list {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        .variant-tag {
            background: rgba(168, 85, 247, 0.15);
            border: 1px solid rgba(168, 85, 247, 0.3);
            padding: 6px 12px;
            border-radius: var(--radius-lg);
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            color: var(--color-text-primary);
            transition: all var(--transition-base);
        }

        .variant-tag:hover {
            background: rgba(168, 85, 247, 0.25);
            border-color: var(--color-accent);
        }

        .variant-tag span {
            cursor: pointer;
            color: var(--color-text-secondary);
            font-weight: bold;
            transition: color var(--transition-fast);
        }

        .variant-tag span:hover {
            color: var(--color-danger);
        }

        /* ===== MAPPING ===== */
        .mapping-item {
            background: rgba(15, 23, 42, 0.4);
            border: 1px solid var(--color-surface-border);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            border-radius: var(--radius-base);
            display: flex;
            gap: var(--spacing-md);
            align-items: center;
            transition: all var(--transition-base);
        }

        .mapping-item:hover {
            background: rgba(15, 23, 42, 0.6);
            border-color: rgba(var(--color-accent-rgb), 0.3);
        }

        .map-swatch {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid var(--color-surface-border);
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .map-select {
            font-size: 0.85em;
            padding: 6px;
            flex: 1;
        }

        /* ===== PRICE SUMMARY ===== */
        .price-summary {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(34, 197, 94, 0.05));
            border: 1px solid rgba(34, 197, 94, 0.3);
            padding: var(--spacing-lg);
            border-radius: var(--radius-base);
            margin-top: var(--spacing-md);
            backdrop-filter: blur(var(--blur-sm));
        }

        .total-price {
            font-size: 1.5em;
            font-weight: 700;
            background: linear-gradient(to right, #22c55e, #86efac);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: right;
        }

        /* ===== PROJECT AREA (RIGHT SIDE) ===== */
        .project-area {
            background: var(--color-surface);
            backdrop-filter: blur(var(--blur-base));
            -webkit-backdrop-filter: blur(var(--blur-base));
            border: 1px solid var(--color-surface-border);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-card);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        .project-area::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: var(--gradient-primary);
            border-radius: var(--radius-xl);
            opacity: 0;
            transition: opacity var(--transition-base);
            z-index: -1;
            filter: blur(15px);
        }

        .project-area:hover::before {
            opacity: 0.2;
        }

        /* ===== TOP TOOLBAR ===== */
        .top-bar {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(var(--blur-sm));
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--color-surface-border);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            flex-wrap: wrap;
            min-height: 60px;
        }

        .top-bar-title {
            font-size: 0.75em;
            font-weight: 700;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-right: var(--spacing-sm);
        }

        .panel-btn {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(var(--blur-sm));
            border: 1px solid var(--color-surface-border);
            padding: 10px 18px;
            border-radius: var(--radius-base);
            font-weight: 600;
            color: var(--color-text-primary);
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all var(--transition-base);
        }

        .panel-btn:hover {
            background: rgba(30, 41, 59, 0.8);
            border-color: rgba(var(--color-accent-rgb), 0.5);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .panel-btn.active {
            background: linear-gradient(135deg, rgba(var(--color-accent-rgb), 0.3), rgba(var(--color-accent-rgb), 0.15));
            border: 2px solid var(--color-accent);
            color: var(--color-accent);
            box-shadow: 0 0 0 3px rgba(var(--color-accent-rgb), 0.2);
            transform: scale(1.05);
        }

        .panel-btn span {
            font-size: 0.8em;
            font-weight: normal;
            color: var(--color-text-muted);
        }

        .btn-add-panel {
            background: linear-gradient(135deg, var(--color-success), rgba(34, 197, 94, 0.7));
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: var(--radius-base);
            font-weight: 600;
            font-size: 0.95em;
            margin-left: var(--spacing-md);
            cursor: pointer;
            transition: all var(--transition-base);
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.3);
        }

        .btn-add-panel:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.5);
        }

        .btn-add-panel:disabled {
            background: rgba(100, 116, 139, 0.3);
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
        }

        .mode-toggle {
            background: linear-gradient(135deg, var(--color-accent), rgba(var(--color-accent-rgb), 0.7));
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--radius-base);
            font-weight: 600;
            font-size: 0.9em;
            margin-left: auto;
            box-shadow: 0 4px 15px rgba(var(--color-accent-rgb), 0.3);
            transition: all var(--transition-base);
        }

        .mode-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(var(--color-accent-rgb), 0.5);
        }

        /* ===== WORKSPACE ===== */
        .workspace {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }

        /* ===== TOOLS BAR (LEFT VERTICAL) ===== */
        .tools-bar {
            width: 70px;
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(var(--blur-sm));
            border-right: 1px solid var(--color-surface-border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: var(--spacing-lg) var(--spacing-sm);
            gap: var(--spacing-md);
            overflow-y: auto;
            z-index: 2;
            scrollbar-width: thin;
            scrollbar-color: rgba(168, 85, 247, 0.3) transparent;
        }

        .tools-bar::-webkit-scrollbar {
            width: 4px;
        }

        .tools-bar::-webkit-scrollbar-thumb {
            background: rgba(168, 85, 247, 0.3);
            border-radius: 2px;
        }

        .tool-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid var(--color-surface-border);
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all var(--transition-base);
            background-size: cover;
            background-position: center;
            background-color: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(var(--blur-sm));
        }

        .tool-btn:hover {
            transform: scale(1.15);
            z-index: 3;
            border-color: var(--color-accent);
            box-shadow: 0 6px 15px rgba(var(--color-accent-rgb), 0.4);
        }

        .tool-btn.active {
            border-color: var(--color-accent);
            transform: scale(1.15);
            box-shadow: 0 0 0 3px rgba(var(--color-accent-rgb), 0.3);
            background-color: rgba(var(--color-accent-rgb), 0.2);
        }

        .tool-btn.eraser {
            background: rgba(30, 41, 59, 0.6) url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>') no-repeat center;
            border-color: rgba(239, 68, 68, 0.5);
        }

        .tool-btn.eraser.active {
            background-color: rgba(239, 68, 68, 0.2);
            border-color: var(--color-danger);
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.3);
        }

        .tool-sep {
            width: 60%;
            height: 2px;
            background: linear-gradient(to right, transparent, var(--color-surface-border), transparent);
            margin: var(--spacing-sm) 0;
        }

        /* ===== CANVAS CONTAINER ===== */
        .canvas-container {
            flex-grow: 1;
            background: rgba(15, 23, 42, 0.3);
            overflow: auto;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xl);
            padding: var(--spacing-xl);
            scrollbar-width: thin;
            scrollbar-color: rgba(168, 85, 247, 0.3) rgba(30, 41, 59, 0.3);
        }

        .canvas-container::-webkit-scrollbar {
            width: 8px;
        }

        .canvas-container::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.3);
            border-radius: 4px;
        }

        .canvas-container::-webkit-scrollbar-thumb {
            background: rgba(168, 85, 247, 0.3);
            border-radius: 4px;
        }

        .view-section {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(var(--blur-base));
            border: 1px solid var(--color-surface-border);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-card);
            transition: all var(--transition-base);
        }

        .view-section:hover {
            border-color: rgba(var(--color-accent-rgb), 0.3);
            box-shadow: var(--shadow-card-hover);
        }

        .view-header {
            font-size: 1.15em;
            font-weight: 600;
            background: var(--gradient-text);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 2px solid rgba(148, 163, 184, 0.2);
        }

        .canvas-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            border-radius: var(--radius-base);
            overflow: hidden;
        }

        #svgWrapperFront {
            transition: transform 0.05s ease-out;
            will-change: transform;
        }

        svg {
            display: block;
            background: rgba(15, 23, 42, 0.5);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            border-radius: var(--radius-sm);
        }

        .wall-bg {
            fill: rgba(100, 116, 139, 0.3);
            stroke: rgba(148, 163, 184, 0.5);
            stroke-width: 2;
        }

        .panel-rect {
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 2;
            cursor: crosshair;
            transition: all var(--transition-fast);
        }

        .panel-rect.delete-mode {
            cursor: not-allowed;
        }

        .panel-rect:hover {
            stroke: var(--color-accent);
            stroke-width: 3px;
            filter: brightness(1.2);
        }

        .dim-text-panel {
            font-size: 11px;
            font-family: var(--font-primary);
            font-weight: bold;
            pointer-events: none;
            fill: var(--color-text-primary);
        }

        .dim-text-external {
            font-size: 11px;
            font-family: var(--font-primary);
            fill: var(--color-text-secondary);
            font-weight: normal;
        }

        .dim-line {
            stroke: var(--color-text-muted);
            stroke-width: 1;
            stroke-dasharray: 2,2;
        }

        .toolbar-between {
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(var(--blur-base));
            padding: var(--spacing-lg);
            border-radius: var(--radius-lg);
            display: flex;
            gap: var(--spacing-md);
            border: 1px solid var(--color-surface-border);
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--color-text-primary);
            box-shadow: var(--shadow-card);
        }

        /* Add panel button in toolbar - compact styling */
        .toolbar-between .btn-add-panel {
            padding: 8px 16px;
            font-size: 0.95em;
            margin: 0;
            min-height: auto;
        }

        /* ===== SAVE SLOTS ===== */
        .save-slot {
            background: rgba(15, 23, 42, 0.4);
            border: 1px solid var(--color-surface-border);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            border-radius: var(--radius-base);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85em;
            color: var(--color-text-primary);
            transition: all var(--transition-base);
        }

        .save-slot:hover {
            background: rgba(15, 23, 42, 0.6);
            border-color: rgba(var(--color-accent-rgb), 0.3);
        }

        /* ===== PROJECT MESSAGES ===== */
        .project-messages {
            position: relative;
            min-height: 0;
            transition: all var(--transition-base);
        }

        .project-message {
            padding: var(--spacing-lg);
            margin: var(--spacing-md) var(--spacing-xl);
            border-radius: var(--radius-base);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--spacing-md);
            font-size: 0.9em;
            animation: fadeInUp 0.4s ease;
            box-shadow: var(--shadow-card);
            backdrop-filter: blur(var(--blur-sm));
        }

        .project-message-content {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            flex: 1;
        }

        .project-message-icon {
            font-size: 1.3em;
            font-weight: bold;
        }

        .project-message-actions {
            display: flex;
            gap: var(--spacing-sm);
        }

        .project-message-success {
            background: rgba(34, 197, 94, 0.15);
            color: #86efac;
            border-left: 4px solid var(--color-success);
        }

        .project-message-error {
            background: rgba(239, 68, 68, 0.15);
            color: #fca5a5;
            border-left: 4px solid var(--color-danger);
        }

        .project-message-warning {
            background: rgba(245, 158, 11, 0.15);
            color: #fcd34d;
            border-left: 4px solid var(--color-warning);
        }

        .project-message-info {
            background: rgba(6, 182, 212, 0.15);
            color: #67e8f9;
            border-left: 4px solid #06b6d4;
        }

        .project-message-close {
            background: none;
            border: none;
            font-size: 1.3em;
            cursor: pointer;
            opacity: 0.6;
            padding: 0 var(--spacing-sm);
            line-height: 1;
            color: currentColor;
            transition: opacity var(--transition-fast);
        }

        .project-message-close:hover {
            opacity: 1;
        }

        .project-message-btn {
            padding: 6px 16px;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all var(--transition-base);
        }

        .project-message-btn-primary {
            background: var(--color-success);
            color: white;
        }

        .project-message-btn-primary:hover {
            background: #16a34a;
            transform: translateY(-1px);
        }

        .project-message-btn-secondary {
            background: rgba(100, 116, 139, 0.6);
            color: white;
        }

        .project-message-btn-secondary:hover {
            background: rgba(100, 116, 139, 0.8);
            transform: translateY(-1px);
        }

        /* ===== RESPONSIVE - 3-LEVEL SYSTEM ===== */

        /* LEVEL 1: Outer Fold Vertical (< 600px) - Compact Mobile */
        @media (max-width: 600px) {
            :root {
                /* Reduced spacing for compact screens */
                --spacing-xs: var(--spacing-mobile-xs);
                --spacing-sm: var(--spacing-mobile-sm);
                --spacing-md: var(--spacing-mobile-md);
                --spacing-lg: var(--spacing-mobile-lg);
                --spacing-xl: var(--spacing-mobile-xl);

                /* Reduced blur for performance */
                --blur-base: 6px;
                --blur-lg: 12px;
            }

            html {
                font-size: 14px; /* 87.5% of base */
            }

            /* Disable animated blobs for performance on compact screens */
            .animated-bg__blob {
                opacity: 0.2;
                animation: none;
                filter: blur(20px); /* Reduced blur */
            }

            .layout {
                display: block;
                height: auto;
                gap: var(--spacing-md);
            }

            .controls {
                height: auto;
                max-height: none;
                margin-bottom: var(--spacing-lg);
                overflow: visible;
                padding-right: 0;
            }

            .card {
                padding: var(--spacing-lg);
                border-radius: var(--radius-lg);
            }

            h3 {
                font-size: 1em;
                margin-bottom: var(--spacing-md);
            }

            .project-area {
                min-height: 500px;
                height: auto;
            }

            .top-bar {
                padding: var(--spacing-md);
                min-height: auto;
                flex-wrap: nowrap;
                overflow-x: visible; /* Don't scroll the whole bar */
                -webkit-overflow-scrolling: touch;
            }

            .top-bar-title {
                font-size: 0.65em;
                margin-right: var(--spacing-xs);
                white-space: nowrap;
                flex-shrink: 0;
            }

            /* Hide hint text on compact screens */
            .top-bar .top-bar-title:last-child {
                display: none;
            }

            /* Panel buttons container - make it scrollable */
            #topVariantsButtons {
                flex: 1;
                min-width: 0; /* Allow flex to shrink */
                overflow-x: auto !important;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                padding: 2px 0;
                display: flex !important;
                gap: 8px !important;
            }

            #topVariantsButtons::-webkit-scrollbar {
                height: 4px;
            }

            #topVariantsButtons::-webkit-scrollbar-thumb {
                background: rgba(168, 85, 247, 0.5);
                border-radius: 2px;
            }

            .panel-btn {
                padding: 8px 14px;
                font-size: 0.85em;
                min-width: 80px;
                min-height: 44px; /* Touch target */
                flex-shrink: 0;
            }

            .workspace {
                flex-direction: column;
            }

            .tools-bar {
                width: 100%;
                height: auto;
                flex-direction: row;
                border-right: none;
                border-bottom: 1px solid var(--color-surface-border);
                padding: var(--spacing-md);
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .tool-btn {
                width: 52px;
                height: 52px; /* Touch target */
                flex-shrink: 0;
            }

            .canvas-container {
                padding: var(--spacing-md);
                gap: var(--spacing-md);
            }

            .view-section {
                padding: var(--spacing-md);
            }

            .view-header {
                font-size: 1em;
                margin-bottom: var(--spacing-md);
                padding-bottom: var(--spacing-sm);
            }

            .canvas-wrapper {
                min-height: 250px;
            }

            .toolbar-between {
                padding: var(--spacing-md);
                gap: var(--spacing-sm);
                flex-wrap: wrap;
            }

            .toolbar-between button {
                min-width: 44px;
                min-height: 44px;
                padding: 8px 12px !important;
                font-size: 1em;
            }

            /* Add panel button - larger on mobile for visibility */
            .toolbar-between .btn-add-panel {
                min-width: 80px;
                padding: 10px 16px !important;
                font-size: 1em !important;
            }

            .toolbar-between span {
                min-width: 50px;
                text-align: center;
            }

            .total-price {
                font-size: 1.3em;
            }

            .project-message {
                margin: var(--spacing-sm) var(--spacing-md);
                padding: var(--spacing-md);
                font-size: 0.85em;
            }

            .segment-row {
                padding: var(--spacing-sm);
                font-size: 0.85em;
            }

            .mapping-item {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--spacing-sm);
            }

            .map-swatch {
                width: 36px;
                height: 36px;
            }

            /* Form inputs - larger touch targets */
            input[type="number"],
            input[type="text"],
            select {
                min-height: 44px;
                font-size: 1em;
            }

            .segment-angle-input {
                min-width: 50px;
                min-height: 36px;
            }

            .angle-btn,
            .btn-x {
                min-height: 36px;
                min-width: 36px;
                padding: 6px 12px;
            }

            .btn-secondary,
            .btn-danger,
            .btn-add-segment {
                min-height: 44px;
                font-size: 0.95em;
            }

            /* Checkboxes and radio - larger for touch */
            input[type="checkbox"],
            input[type="radio"] {
                width: 20px;
                height: 20px;
                margin-right: 8px;
            }

            /* Variant tags - larger touch area */
            .variant-tag {
                padding: 8px 14px;
                min-height: 40px;
            }

            /* Save slots - larger touch area */
            .save-slot {
                padding: var(--spacing-md);
                min-height: 50px;
            }

            /* Disable hover effects on touch (not reliable on mobile) */
            .card:hover {
                transform: none;
            }

            .panel-btn:hover {
                transform: none;
            }

            .tool-btn:hover {
                transform: none;
            }

            .btn-add-panel:hover {
                transform: none;
            }

            .mode-toggle:hover {
                transform: none;
            }
        }

        /* LEVEL 2: Outer Fold Horizontal / Small Tablets (601px - 900px) */
        @media (min-width: 601px) and (max-width: 900px) {
            html {
                font-size: 15px; /* 93.75% of base */
            }

            .layout {
                display: block;
                height: auto;
                gap: var(--spacing-lg);
            }

            .controls {
                height: auto;
                max-height: none;
                margin-bottom: var(--spacing-xl);
                overflow: visible;
            }

            .project-area {
                min-height: 600px;
                height: auto;
            }

            .top-bar {
                padding: var(--spacing-lg);
                overflow-x: visible;
                -webkit-overflow-scrolling: touch;
            }

            /* Panel buttons container - scrollable */
            #topVariantsButtons {
                flex: 1;
                min-width: 0;
                overflow-x: auto !important;
                -webkit-overflow-scrolling: touch;
            }

            .panel-btn {
                min-height: 44px; /* Touch target */
                flex-shrink: 0;
            }

            .tools-bar {
                width: 100%;
                height: auto;
                flex-direction: row;
                border-right: none;
                border-bottom: 1px solid var(--color-surface-border);
                padding: var(--spacing-md) var(--spacing-lg);
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                gap: var(--spacing-sm);
            }

            .tool-btn {
                width: 50px;
                height: 50px;
                flex-shrink: 0;
            }

            .workspace {
                flex-direction: column;
            }

            .toolbar-between button {
                min-width: 44px;
                min-height: 44px;
            }

            .canvas-container {
                gap: var(--spacing-lg);
            }
        }

        /* LEVEL 3: Inner Fold Open / Tablets (901px - 1200px) */
        @media (min-width: 901px) and (max-width: 1200px) {
            html {
                font-size: 15px; /* 93.75% of base */
            }

            .layout {
                grid-template-columns: 280px 1fr; /* Narrower sidebar */
                gap: var(--spacing-lg);
            }

            .controls {
                gap: var(--spacing-md);
            }

            .card {
                padding: var(--spacing-lg);
            }

            h3 {
                font-size: 1.05em;
            }

            .panel-btn {
                min-height: 44px; /* Touch target maintained */
            }

            .tool-btn {
                width: 46px;
                height: 46px;
            }
        }

        /* ===== TOUCH OPTIMIZATION ===== */
        .canvas-wrapper,
        svg {
            touch-action: pan-x pan-y pinch-zoom;
        }

        .top-bar,
        .tools-bar {
            touch-action: pan-x;
        }

        button,
        .panel-btn,
        .tool-btn {
            touch-action: manipulation; /* Disable double-tap zoom */
        }

        /* Prevent text selection during interaction */
        .workspace,
        .canvas-container,
        svg {
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }

        /* ===== REDUCED MOTION ===== */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>

<!-- Animated Background -->
<div class="animated-bg">
    <div class="animated-bg__blob"></div>
    <div class="animated-bg__blob"></div>
    <div class="animated-bg__blob"></div>
</div>

<div class="layout">

    <!-- 1. LEWA KOLUMNA (KONFIGURACJA) -->
    <div class="controls fade-in-up">

        <!-- Kszta≈Çt obszaru roboczego -->
        <div class="card delay-100">
            <h3>1. Kszta≈Çt obszaru roboczego</h3>
            <div id="segmentsContainer"></div>

            <div style="background: rgba(15, 23, 42, 0.3); padding: 12px; border: 1px dashed rgba(148, 163, 184, 0.3); margin-top: 12px; border-radius: var(--radius-base);">
                <div class="row-inputs" style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px;">
                    <input type="number" id="segWidth" placeholder="Szer.">
                    <input type="number" id="segStartHeight" placeholder="np. 140">
                    <input type="number" id="segEndHeight" placeholder="Wys. ko≈Ñc.">
                </div>
                <button class="btn-add-segment" onclick="addSegment()">+ Dodaj Segment</button>
            </div>
            <button class="btn-secondary" style="width:100%; margin-top:12px; background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.1)); border-color: rgba(34, 197, 94, 0.5); color: #86efac;" onclick="loadPresetWorkspace()">üìã Wczytaj przyk≈Çad U-shaped</button>
            <button class="btn-danger" onclick="resetWall()">Resetuj Obszar</button>
        </div>

        <!-- Konfiguracja Paneli -->
        <div class="card delay-200">
            <h3>2. Konfiguracja Paneli</h3>
            <p style="font-size:0.8em; color: var(--color-text-secondary); margin-bottom:8px;">Zdefiniuj wymiary paneli (szer √ó wys) dostƒôpne do uk≈Çadania.</p>
            <div class="row-inputs" style="display:grid; grid-template-columns:1fr 1fr auto; gap:5px;">
                <input type="number" id="newVariantWidth" placeholder="Szer.">
                <input type="number" id="newVariantHeight" placeholder="Wys.">
                <button class="btn-secondary" onclick="addVariantDefinition()">Dodaj</button>
            </div>
            <div id="variantConfigList" class="variant-config-list"></div>
        </div>

        <!-- Wycena i Mapowanie -->
        <div class="card delay-300" style="border-left: 4px solid var(--color-success);">
            <h3>3. Wycena i Materia≈Çy</h3>

            <div id="mappingContainer" style="margin-bottom:15px;"></div>

            <div style="font-size:0.9em; margin-bottom:10px; display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                <label style="font-weight:normal;"><input type="checkbox" id="optFoam" onchange="updatePanelDepth(); recalculatePrice()"> Podw√≥jna pianka (5cm)</label>
                <label style="font-weight:normal;"><input type="checkbox" id="optVelcro" onchange="recalculatePrice()"> Rzep monta≈ºowy</label>
                <label style="font-weight:normal;"><input type="checkbox" id="optShipping" checked onchange="recalculatePrice()"> Wysy≈Çka</label>
            </div>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                <div class="form-group">
                    <label>Otwory na kontakt (szt):</label>
                    <input type="number" id="optOutlets" value="0" min="0" onchange="recalculatePrice()">
                </div>
                <div class="form-group">
                    <label>Klej (szt):</label>
                    <input type="number" id="optGlue" value="0" min="0" onchange="recalculatePrice()">
                </div>
            </div>

            <div class="price-summary">
                <div class="total-price" id="totalPriceDisplay">0.00 z≈Ç</div>
                <div style="font-size:0.8em; color: var(--color-text-secondary); margin-top:8px;" id="priceDetails"></div>
            </div>
        </div>

        <!-- Zapis -->
        <div class="card delay-400">
            <h3>Zapisane Projekty</h3>
            <button class="btn-secondary" style="width:100%; margin-bottom:10px; background: linear-gradient(135deg, rgba(6, 182, 212, 0.2), rgba(6, 182, 212, 0.1)); border-color: rgba(6, 182, 212, 0.5); color: #67e8f9;" onclick="saveCurrentLayout()">üíæ Zapisz obecny uk≈Çad</button>
            <div id="savesContainer"></div>
        </div>

    </div>

    <!-- 2. PRAWA STRONA (PROJEKT) -->
    <div class="project-area fade-in-up delay-100">

        <!-- NAG≈Å√ìWEK PROJEKTU -->
        <div style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.3), rgba(118, 75, 162, 0.3)); backdrop-filter: blur(8px); padding: 20px; border-bottom: 1px solid rgba(148, 163, 184, 0.2);">
            <h2 style="margin: 0; font-size: 1.4em; font-weight: 700; background: linear-gradient(to right, #06b6d4, #a78bfa, #f472b6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">‚ú® Kreator Paneli Tapicerowanych</h2>
        </div>

        <!-- TOP BAR: SZYBKIE DODAWANIE -->
        <div class="top-bar" id="topBar">
            <div class="top-bar-title">Wybierz panel:</div>
            <div id="topVariantsButtons" style="display:flex; gap:8px; overflow-x:auto;"></div>
            <div class="top-bar-title" style="margin-left:auto; font-size:0.75em; color:#999;">Kliknij w obszar aby ustawiƒá pozycjƒô preview</div>
        </div>

        <!-- KOMUNIKATY PROJEKTU -->
        <div id="projectMessages" class="project-messages"></div>

        <!-- WORKSPACE -->
        <div class="workspace">
            <!-- LEFT BAR: NARZƒòDZIA -->
            <div class="tools-bar" id="toolsBar">
                <!-- Generowane JS (Kolory + Gumka) -->
            </div>

            <!-- CANVAS CONTAINER - dwa widoki -->
            <div class="canvas-container">
                <!-- WIDOK FRONTALNY -->
                <div class="view-section">
                    <div class="view-header">üìê Widok Frontalny (rozwiniƒôcie)</div>
                    <div class="canvas-wrapper">
                        <div id="svgWrapperFront"></div>
                    </div>
                </div>

                <!-- PRZYBORNIK (zsynchronizowany dla obu widok√≥w) -->
                <div class="toolbar-between">
                    <button id="addPanelBtn" onclick="addPanelFromButton()" class="btn-add-panel" disabled title="Dodaj wybrany panel">‚úì Dodaj</button>
                    <span style="color:#ccc">|</span>
                    <button onclick="changeZoom(-0.1)" class="btn-secondary" style="padding:2px 6px;">-</button>
                    <span id="zoomLabel">100%</span>
                    <button onclick="changeZoom(0.1)" class="btn-secondary" style="padding:2px 6px;">+</button>
                    <span style="color:#ccc">|</span>
                    <button onclick="undoPanel()" class="btn-secondary" title="Cofnij ostatni panel" style="padding:2px 6px;">‚Ü©</button>
                    <button onclick="clearWorkspace()" class="btn-secondary" title="Wyczy≈õƒá obszar roboczy" style="padding:2px 6px;">üóëÔ∏è</button>
                </div>

                <!-- WIDOK Z G√ìRY -->
                <div class="view-section">
                    <div class="view-header">üîç Widok z G√≥ry (rzut poziomy)</div>
                    <div class="canvas-wrapper">
                        <div id="svgWrapperTop"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>

<script>
    // --- DANE CENOWE ---
    // ROZMIARY PANELI - Tabele cenowe (Standard/Premium/Exclusive)
    const RozmStandard = {
        // KLASYCZNE
        "20x20": 21, "20x30": 22, "20x40": 24, "30x30": 24, "30x40": 25, "30x50": 26, "30x60": 28,
        "30x70": 35, "30x80": 39, "30x90": 45, "30x100": 50, "30x120": 75, "40x40": 26, "40x50": 32,
        "40x60": 35, "40x70": 46, "40x80": 53, "40x90": 60, "40x100": 69, "40x120": 89, "50x50": 43,
        "50x60": 51, "50x70": 61, "60x60": 63,
        // LONGI
        "20x50": 24, "20x60": 25, "20x70": 29, "20x80": 29, "20x90": 33, "20x100": 45, "20x110": 50,
        "20x120": 55, "20x130": 59, "20x140": 63, "20x150": 67, "20x160": 70, "20x170": 78, "20x180": 85,
        "20x190": 94, "20x200": 100, "20x210": 109, "20x220": 115, "20x230": 120, "20x240": 125,
        "20x250": 135, "20x260": 140, "15x50": 24, "15x60": 25, "15x70": 29, "15x80": 29, "15x90": 33,
        "15x100": 45, "15x110": 50, "15x120": 55, "15x130": 58, "15x140": 60, "15x150": 63, "15x160": 70,
        "15x170": 78, "15x180": 85, "15x190": 94, "15x200": 100, "15x210": 109, "15x220": 115,
        "15x230": 120, "15x240": 125, "15x250": 135, "15x260": 140, "10x50": 24, "10x60": 24, "10x70": 29,
        "10x80": 29, "10x90": 29, "10x100": 39, "10x110": 45, "10x120": 50, "10x130": 54, "10x140": 58,
        "10x150": 61, "10x160": 65, "10x170": 73, "10x180": 80, "10x190": 88, "10x200": 95, "10x210": 105,
        "10x220": 110, "10x230": 115, "10x240": 120, "10x250": 130, "10x260": 135
    };

    const RozmPremium = {
        // KLASYCZNE
        "20x20": 25, "20x30": 28, "20x40": 29, "30x30": 28, "30x40": 30, "30x50": 31, "30x60": 33,
        "30x70": 40, "30x80": 46, "30x90": 51, "30x100": 59, "30x120": 85, "40x40": 31, "40x50": 37,
        "40x60": 40, "40x70": 51, "40x80": 60, "40x90": 68, "40x100": 79, "40x120": 99, "50x50": 49,
        "50x60": 58, "50x70": 71, "60x60": 73,
        // LONGI
        "20x50": 30, "20x60": 31, "20x70": 34, "20x80": 34, "20x90": 38, "20x100": 50, "20x110": 55,
        "20x120": 60, "20x130": 64, "20x140": 68, "20x150": 71, "20x160": 75, "20x170": 85, "20x180": 90,
        "20x190": 100, "20x200": 110, "20x210": 115, "20x220": 120, "20x230": 125, "20x240": 130,
        "20x250": 139, "20x260": 145, "15x50": 30, "15x60": 31, "15x70": 34, "15x80": 34, "15x90": 34,
        "15x100": 50, "15x110": 55, "15x120": 60, "15x130": 64, "15x140": 68, "15x150": 71, "15x160": 75,
        "15x170": 85, "15x180": 90, "15x190": 100, "15x200": 110, "15x210": 115, "15x220": 120,
        "15x230": 125, "15x240": 130, "15x250": 139, "15x260": 145, "10x50": 28, "10x60": 28, "10x70": 31,
        "10x80": 31, "10x90": 31, "10x100": 39, "10x110": 45, "10x120": 50, "10x130": 54, "10x140": 58,
        "10x150": 61, "10x160": 65, "10x170": 75, "10x180": 80, "10x190": 90, "10x200": 95, "10x210": 105,
        "10x220": 110, "10x230": 115, "10x240": 120, "10x250": 130, "10x260": 135
    };

    const RozmExclusive = {
        // KLASYCZNE
        "20x20": 27, "20x30": 30, "20x40": 32, "30x30": 32, "30x40": 35, "30x50": 36, "30x60": 38,
        "30x70": 45, "30x80": 51, "30x90": 56, "30x100": 65, "30x120": 90, "40x40": 35, "40x50": 42,
        "40x60": 45, "40x70": 55, "40x80": 65, "40x90": 70, "40x100": 85, "40x120": 105, "50x50": 51,
        "50x60": 60, "50x70": 75, "60x60": 78,
        // LONGI
        "20x50": 33, "20x60": 34, "20x70": 39, "20x80": 39, "20x90": 43, "20x100": 55, "20x110": 60,
        "20x120": 65, "20x130": 69, "20x140": 73, "20x150": 77, "20x160": 80, "20x170": 90, "20x180": 95,
        "20x190": 110, "20x200": 115, "20x210": 120, "20x220": 125, "20x230": 130, "20x240": 135,
        "20x250": 145, "20x260": 150, "15x50": 33, "15x60": 34, "15x70": 39, "15x80": 39, "15x90": 39,
        "15x100": 55, "15x110": 60, "15x120": 65, "15x130": 69, "15x140": 73, "15x150": 77, "15x160": 80,
        "15x170": 90, "15x180": 95, "15x190": 110, "15x200": 115, "15x210": 120, "15x220": 125,
        "15x230": 130, "15x240": 135, "15x250": 145, "15x260": 150, "10x50": 32, "10x60": 32, "10x70": 34,
        "10x80": 34, "10x90": 34, "10x100": 44, "10x110": 49, "10x120": 55, "10x130": 59, "10x140": 63,
        "10x150": 67, "10x160": 70, "10x170": 80, "10x180": 85, "10x190": 95, "10x200": 100, "10x210": 110,
        "10x220": 115, "10x230": 120, "10x240": 125, "10x250": 135, "10x260": 140
    };

    // --- KOLEKCJE TKANIN ---
    const Collections = {
        Standard: ['DIANA', 'LUNA', 'SWEET', 'TANGO', 'NUBUK', 'TREND', 'OLIMP', 'TRINITY'],
        Premium: ['KRONOS', 'RODOS', 'FOREST', 'CROWN', 'MONOLITH', 'EVO', 'FRESH', 'PRESTON'],
        Exclusive: ['VELVET', 'ALCANTARA', 'LOFT', 'JAZZ']
    };

    // Paleta wizualna
    const visualPalette = [
        { hex: '#5d3a75', name: 'Fiolet' }, { hex: '#8e8e93', name: 'Szary' },
        { hex: '#d2b48c', name: 'Be≈º' }, { hex: '#1a2a6c', name: 'Granat' },
        { hex: '#2d5a27', name: 'Ziele≈Ñ' }, { hex: '#e6bece', name: 'Pudrowy' },
        { hex: '#d4af37', name: '≈ª√≥≈Çty' }, { hex: '#333333', name: 'Grafit' }
    ];
    // Dekor (Base64)
    const floralTex = "data:image/svg+xml,%3Csvg width='50' height='50' viewBox='0 0 50 50' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='50' height='50' fill='%236a4c93'/%3E%3Ccircle cx='25' cy='25' r='10' fill='%23ffffff' opacity='0.2'/%3E%3Cpath d='M25 15 L35 25 L25 35 L15 25 Z' fill='%23ffffff' opacity='0.2'/%3E%3C/svg%3E";
    const visualTextures = [{ file: floralTex, name: 'Dekor' }];

    // --- STAN ---
    let wallData = { segments: [], masterSegmentIndex: 0 }; // segments: [{width, startHeight, endHeight, angle}]
    let variants = [
        {width: 30, height: 100},
        {width: 20, height: 140},
        {width: 30, height: 40}
    ]; // Domy≈õlne wymiary
    let panels = []; // {width, height, x, y, style}
    let activeTool = { type: 'color', value: visualPalette[0].hex }; // 'eraser' lub {type, value}
    let styleMapping = {};
    let layoutMode = 'horizontal'; // 'horizontal' | 'vertical'
    let zoomLevel = 1.0;
    let selectedPanelSize = null; // {width, height} - wybrany panel do dodania (hover)
    let lastUsedPanelSize = null; // {width, height} - ostatnio dodany panel (auto-preview)
    let previewPosition = null; // {x, y} - pozycja preview (z myszki lub smart snap)
    let previewLocked = false; // Czy preview jest "zamro≈ºony" po snapie
    let selectedVariant = null; // {width, height} - aktywnie wybrany rozmiar (dla pod≈õwietlenia)
    let panelDepth = 2.5; // Grubo≈õƒá panelu w cm (default 2.5cm)
    const STORAGE_KEY = 'panelConfig_V7_Saves';

    // --- TOUCH STATE (FAZA 2) ---
    let touchState = {
        active: false,
        startX: 0,
        startY: 0,
        lastX: 0,
        lastY: 0,
        startTime: 0,
        longPressTimer: null,
        // Pan/scroll state
        isPanning: false,
        panX: 0,
        panY: 0,
        initialPanX: 0,
        initialPanY: 0
    };

    // --- SYSTEM KOMUNIKAT√ìW PROJEKTU ---
    function showProjectMessage(text, type = 'info', duration = 4000) {
        const container = document.getElementById('projectMessages');

        // Usu≈Ñ poprzednie komunikaty
        container.innerHTML = '';

        // Ikony dla typ√≥w
        const icons = {
            success: '‚úì',
            info: '‚Ñπ',
            warning: '‚ö†',
            error: '‚úï'
        };

        const messageDiv = document.createElement('div');
        messageDiv.className = `project-message project-message-${type}`;
        messageDiv.innerHTML = `
            <div class="project-message-content">
                <span class="project-message-icon">${icons[type]}</span>
                <span>${text}</span>
            </div>
            <button class="project-message-close" onclick="this.parentElement.remove()">√ó</button>
        `;

        container.appendChild(messageDiv);

        // Auto-hide po okre≈õlonym czasie
        if (duration > 0) {
            setTimeout(() => {
                if (messageDiv.parentElement) {
                    messageDiv.remove();
                }
            }, duration);
        }
    }

    function showProjectConfirm(text, onConfirm) {
        const container = document.getElementById('projectMessages');

        // Usu≈Ñ poprzednie komunikaty
        container.innerHTML = '';

        const messageDiv = document.createElement('div');
        messageDiv.className = 'project-message project-message-warning';
        messageDiv.innerHTML = `
            <div class="project-message-content">
                <span class="project-message-icon">‚ö†</span>
                <span>${text}</span>
            </div>
            <div class="project-message-actions">
                <button class="project-message-btn project-message-btn-primary" onclick="handleConfirmYes()">TAK</button>
                <button class="project-message-btn project-message-btn-secondary" onclick="handleConfirmNo()">ANULUJ</button>
            </div>
        `;

        container.appendChild(messageDiv);

        // Przechowuj callback w globalnej zmiennej tymczasowej
        window._projectConfirmCallback = () => {
            messageDiv.remove();
            onConfirm();
        };
    }

    function handleConfirmYes() {
        if (window._projectConfirmCallback) {
            window._projectConfirmCallback();
            delete window._projectConfirmCallback;
        }
    }

    function handleConfirmNo() {
        const container = document.getElementById('projectMessages');
        container.innerHTML = '';
        delete window._projectConfirmCallback;
    }

    // --- GRUBO≈öƒÜ PANELU ---
    function updatePanelDepth() {
        const foamChecked = document.getElementById('optFoam').checked;
        panelDepth = foamChecked ? 5.0 : 2.5;
        draw(); // Od≈õwie≈º widok z g√≥ry
    }

    // --- INIT ---
    document.addEventListener('DOMContentLoaded', () => {
        renderSegmentsList();
        renderVariantConfig(); // Lewy panel (konfiguracja)
        renderTopBar();        // G√≥rny pasek (u≈ºycie)
        renderToolsBar();      // Pasek narzƒôdzi
        renderSaves();
        draw();
        updateMappingUI();

        // Obs≈Çuga klikniƒôƒá w obszar roboczy (mouse)
        const svgWrapper = document.getElementById('svgWrapperFront');
        svgWrapper.addEventListener('click', onCanvasClick);
        svgWrapper.addEventListener('mousemove', onCanvasMouseMove);

        // Obs≈Çuga touch events (FAZA 2)
        svgWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
        svgWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
        svgWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
        svgWrapper.addEventListener('touchcancel', handleTouchCancel, { passive: false });
    });

    // --- 1. ZARZƒÑDZANIE WARIANTAMI (SEKCJA 2 + TOP BAR) ---
    function addVariantDefinition() {
        const w = parseFloat(document.getElementById('newVariantWidth').value);
        const h = parseFloat(document.getElementById('newVariantHeight').value);

        if (w > 0 && h > 0) {
            const exists = variants.some(v => v.width === w && v.height === h);
            if (!exists) {
                variants.push({width: w, height: h});
                variants.sort((a,b) => (b.width * b.height) - (a.width * a.height));
                renderVariantConfig();
                renderTopBar();
                document.getElementById('newVariantWidth').value = '';
                document.getElementById('newVariantHeight').value = '';
            }
        }
    }

    function removeVariantDefinition(w, h) {
        variants = variants.filter(v => !(v.width === w && v.height === h));
        renderVariantConfig();
        renderTopBar();
    }

    function renderVariantConfig() {
        // Lista w sekcji 2 (do usuwania)
        const c = document.getElementById('variantConfigList');
        c.innerHTML = '';
        variants.forEach(v => {
            const tag = document.createElement('div');
            tag.className = 'variant-tag';
            tag.innerHTML = `${v.width}√ó${v.height} cm <span onclick="removeVariantDefinition(${v.width}, ${v.height})">&times;</span>`;
            c.appendChild(tag);
        });
    }

    function selectVariant(width, height) {
        selectedVariant = {width, height};
        lastUsedPanelSize = {width, height};
        previewPosition = null; // Reset preview position przy zmianie rozmiaru
        previewLocked = false; // Odblokuj preview przy zmianie rozmiaru
        renderTopBar(); // Od≈õwie≈º aby pokazaƒá active state
        draw();
    }

    function addPanelFromButton() {
        if (!lastUsedPanelSize) {
            showProjectMessage('Najpierw wybierz rozmiar panelu!', 'warning');
            return;
        }
        addPanel(lastUsedPanelSize.width, lastUsedPanelSize.height);
    }

    function renderTopBar() {
        // Przyciski w Top Bar (wyb√≥r rozmiaru)
        const c = document.getElementById('topVariantsButtons');
        c.innerHTML = '';

        variants.forEach(v => {
            const btn = document.createElement('button');
            const isActive = selectedVariant && selectedVariant.width === v.width && selectedVariant.height === v.height;
            btn.className = `panel-btn ${isActive ? 'active' : ''}`;
            btn.innerHTML = `${v.width}√ó${v.height}`;
            btn.onmouseenter = () => {
                if (!isActive) {
                    selectedPanelSize = {width: v.width, height: v.height};
                    draw();
                }
            };
            btn.onmouseleave = () => {
                selectedPanelSize = null;
                draw();
            };
            btn.onclick = () => {
                selectedPanelSize = null;
                // Toggle: je≈õli ju≈º active, odkliknij (wy≈ÇƒÖcz preview)
                if (isActive) {
                    selectedVariant = null;
                    lastUsedPanelSize = null;
                    previewPosition = null;
                    previewLocked = false;
                } else {
                    selectVariant(v.width, v.height);
                }
                renderTopBar();
                draw();
            };
            c.appendChild(btn);
        });

        // Aktualizuj stan przycisku "Dodaj" w toolbar
        const addBtn = document.getElementById('addPanelBtn');
        if (addBtn) {
            addBtn.disabled = !lastUsedPanelSize;
        }
    }

    // --- 2. NARZƒòDZIA (LEFT VERTICAL BAR) ---
    function renderToolsBar() {
        const c = document.getElementById('toolsBar');
        c.innerHTML = '';

        // 1. Gumka
        const eraser = document.createElement('div');
        eraser.className = `tool-btn eraser ${activeTool==='eraser'?'active':''}`;
        eraser.title = "Usu≈Ñ Panel (Kliknij panel aby usunƒÖƒá)";
        eraser.onclick = () => setActiveTool('eraser');
        c.appendChild(eraser);

        c.appendChild(document.createElement('div')).className = 'tool-sep';

        // 2. Kolory
        visualPalette.forEach(item => {
            const el = document.createElement('div');
            const isActive = activeTool.type === 'color' && activeTool.value === item.hex;
            el.className = `tool-btn ${isActive?'active':''}`;
            el.style.backgroundColor = item.hex;
            el.title = item.name;
            el.onclick = () => setActiveTool({ type: 'color', value: item.hex });
            c.appendChild(el);
        });

        c.appendChild(document.createElement('div')).className = 'tool-sep';

        // 3. Tekstury
        visualTextures.forEach(item => {
            const el = document.createElement('div');
            const isActive = activeTool.type === 'image' && activeTool.value === item.file;
            el.className = `tool-btn ${isActive?'active':''}`;
            el.style.backgroundImage = `url('${item.file}')`;
            el.title = item.name;
            el.onclick = () => setActiveTool({ type: 'image', value: item.file });
            c.appendChild(el);
        });
    }

    function setActiveTool(tool) {
        activeTool = tool;
        renderToolsBar(); // Od≈õwie≈º ramki
    }

    // --- 3. INTERAKCJA Z PROJEKTEM ---

    // Oblicza kolor tekstu (czarny/bia≈Çy) na podstawie jasno≈õci t≈Ça dla optymalnego kontrastu
    function getContrastColor(hexColor) {
        // Je≈õli to data:image (tekstura), zwr√≥ƒá bia≈Çy z cieniem
        if (hexColor.startsWith('data:')) {
            return { fill: 'white', shadow: '0 0 3px rgba(0,0,0,0.8)' };
        }

        // Konwersja hex na RGB
        let r, g, b;
        if (hexColor.startsWith('#')) {
            const hex = hexColor.slice(1);
            if (hex.length === 3) {
                r = parseInt(hex[0] + hex[0], 16);
                g = parseInt(hex[1] + hex[1], 16);
                b = parseInt(hex[2] + hex[2], 16);
            } else {
                r = parseInt(hex.slice(0, 2), 16);
                g = parseInt(hex.slice(2, 4), 16);
                b = parseInt(hex.slice(4, 6), 16);
            }
        } else {
            // Fallback dla nieprawid≈Çowych kolor√≥w
            return { fill: 'white', shadow: '0 0 3px rgba(0,0,0,0.8)' };
        }

        // Oblicz luminancjƒô (WCAG formula)
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

        // Jasne t≈Ço ‚Üí czarny tekst, ciemne t≈Ço ‚Üí bia≈Çy tekst
        if (luminance > 0.5) {
            return { fill: 'black', shadow: '0 0 2px rgba(255,255,255,0.5)' };
        } else {
            return { fill: 'white', shadow: '0 0 2px rgba(0,0,0,0.5)' };
        }
    }

    // Sprawdza kolizjƒô z innymi panelami
    function checkPanelCollision(x, y, width, height, excludeIndex = -1) {
        for (let i = 0; i < panels.length; i++) {
            if (i === excludeIndex) continue;
            const p = panels[i];

            // Sprawd≈∫ czy prostokƒÖty siƒô nak≈ÇadajƒÖ
            if (!(x + width <= p.x || x >= p.x + p.width ||
                  y + height <= p.y || y >= p.y + p.height)) {
                return true; // Kolizja!
            }
        }
        return false; // Brak kolizji
    }

    // Silny snap do pustej przestrzeni - snap do najbli≈ºszej krawƒôdzi w lewo i w d√≥≈Ç
    function findBestSnapPosition(clickX, clickY, width, height) {
        // Znajd≈∫ najbli≈ºszƒÖ krawƒôd≈∫ w LEWO (dla X) i w D√ì≈Å (dla Y)

        let snapX = clickX;
        let snapY = clickY;

        // KROK 0: Inteligentny snap wertykalny - sprawd≈∫ czy istniejƒÖ panele "pod" kursorem (pionowa projekcja)
        let panelsBelow = panels.filter(p => {
            // Panel jest "pod" kursorem je≈õli:
            // 1. Jego zakres X zawiera clickX
            // 2. Jego g√≥rna krawƒôd≈∫ jest poni≈ºej lub na poziomie clickY
            return (p.x <= clickX && clickX <= p.x + p.width) &&
                   (p.y + p.height <= clickY);
        });

        if (panelsBelow.length > 0) {
            // Znajd≈∫ najbli≈ºszy panel w pionie (ten z najwiƒôkszym y + height)
            let closestPanel = panelsBelow.reduce((closest, p) => {
                return (p.y + p.height > closest.y + closest.height) ? p : closest;
            });

            // Snapuj do g√≥rnej krawƒôdzi tego panelu
            snapX = closestPanel.x;
            snapY = closestPanel.y + closestPanel.height;

            // Sprawd≈∫ kolizjƒô i dopasowanie
            if (!checkPanelCollision(snapX, snapY, width, height) &&
                checkPanelFits(snapX, snapY, width, height)) {
                return { x: snapX, y: snapY };
            }

            // Je≈õli jest kolizja, spr√≥buj przesunƒÖƒá w prawo
            const searchRadius = 50;
            for (let dx = 5; dx <= searchRadius; dx += 5) {
                const testX = snapX + dx;
                if (!checkPanelCollision(testX, snapY, width, height) &&
                    checkPanelFits(testX, snapY, width, height)) {
                    return { x: testX, y: snapY };
                }
            }

            // Je≈õli nie uda≈Ço siƒô znale≈∫ƒá miejsca, przejd≈∫ do standardowego algorytmu
        }

        // STANDARD SNAP: Je≈õli nie znaleziono panelu "pod" kursorem, u≈ºyj obecnego algorytmu
        // 1. SNAP X (w lewo) - znajd≈∫ najbli≈ºszƒÖ krawƒôd≈∫ po lewej stronie
        let leftEdges = [50]; // Lewa krawƒôd≈∫ obszaru (startX)

        // Dodaj LEWƒÑ i PRAWƒÑ krawƒôd≈∫ wszystkich paneli
        panels.forEach(p => {
            leftEdges.push(p.x);           // Lewa krawƒôd≈∫ panelu
            leftEdges.push(p.x + p.width); // Prawa krawƒôd≈∫ panelu
        });

        // Znajd≈∫ najbli≈ºszƒÖ krawƒôd≈∫ w lewo od klikniƒôcia
        let closestLeftEdge = 50; // Domy≈õlnie lewa krawƒôd≈∫ obszaru
        let minLeftDistance = Infinity;

        leftEdges.forEach(edge => {
            if (edge <= clickX) { // Tylko krawƒôdzie po lewej
                const distance = clickX - edge;
                if (distance < minLeftDistance) {
                    minLeftDistance = distance;
                    closestLeftEdge = edge;
                }
            }
        });

        snapX = closestLeftEdge;

        // 2. SNAP Y (w d√≥≈Ç) - znajd≈∫ najbli≈ºszƒÖ krawƒôd≈∫ poni≈ºej
        let bottomEdges = [0]; // Dolna krawƒôd≈∫ obszaru (floor)

        // Dodaj DOLNƒÑ i G√ìRNƒÑ krawƒôd≈∫ wszystkich paneli
        panels.forEach(p => {
            bottomEdges.push(p.y);             // Dolna krawƒôd≈∫ panelu
            bottomEdges.push(p.y + p.height);  // G√≥rna krawƒôd≈∫ panelu
        });

        // Znajd≈∫ najbli≈ºszƒÖ krawƒôd≈∫ w d√≥≈Ç od klikniƒôcia
        let closestBottomEdge = 0; // Domy≈õlnie dolna krawƒôd≈∫ obszaru
        let minBottomDistance = Infinity;

        bottomEdges.forEach(edge => {
            if (edge <= clickY) { // Tylko krawƒôdzie poni≈ºej
                const distance = clickY - edge;
                if (distance < minBottomDistance) {
                    minBottomDistance = distance;
                    closestBottomEdge = edge;
                }
            }
        });

        snapY = closestBottomEdge;

        // 3. Sprawd≈∫ czy po snapie nie ma kolizji i panel siƒô mie≈õci
        if (checkPanelCollision(snapX, snapY, width, height) ||
            !checkPanelFits(snapX, snapY, width, height)) {

            const searchRadius = 50;
            let minDistance = Infinity;
            let bestX = snapX;
            let bestY = snapY;

            // PRIORYTET 1: Spr√≥buj zachowaƒá snapY (przesuwaj tylko X w prawo)
            // To preferuje uk≈Çadanie NAD istniejƒÖcymi panelami
            for (let dx = 5; dx <= searchRadius; dx += 5) {
                const testX = snapX + dx;
                if (!checkPanelCollision(testX, snapY, width, height) &&
                    checkPanelFits(testX, snapY, width, height)) {
                    return { x: testX, y: snapY }; // Znaleziono! Zachowano Y
                }
            }

            // PRIORYTET 2: Szukaj w innych kierunkach z wagƒÖ preferujƒÖcƒÖ ma≈Çe zmiany Y
            // Waga: ma≈Çe zmiany Y sƒÖ 3x lepsze ni≈º ma≈Çe zmiany X
            for (let dy = 5; dy <= searchRadius; dy += 5) {
                for (let dx = -searchRadius; dx <= searchRadius; dx += 5) {
                    const testX = snapX + dx;
                    const testY = snapY + dy;

                    if (!checkPanelCollision(testX, testY, width, height) &&
                        checkPanelFits(testX, testY, width, height)) {
                        // Waga: ma≈Çe zmiany Y sƒÖ bardziej preferowane (mno≈ºnik 3)
                        const distance = Math.sqrt(dx * dx + (dy * 3) * (dy * 3));
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestX = testX;
                            bestY = testY;
                        }
                    }
                }
            }

            return { x: bestX, y: bestY };
        }

        return { x: snapX, y: snapY };
    }

    // Sprawdza wysoko≈õƒá obszaru roboczego w danym punkcie X
    function getHeightAtPosition(x) {
        if (wallData.segments.length === 0) return 0;

        let currentX = 50;
        let currentHeight = 0;

        for (let i = 0; i < wallData.segments.length; i++) {
            const seg = wallData.segments[i];
            const segStart = currentX;
            const segEnd = currentX + seg.width;

            if (x >= segStart && x < segEnd) {
                // X jest w tym segmencie - interpoluj wysoko≈õƒá
                const ratio = (x - segStart) / seg.width;
                return seg.startHeight + ratio * (seg.endHeight - seg.startHeight);
            }

            if (x >= segEnd && i === wallData.segments.length - 1) {
                // X jest za ostatnim segmentem
                return seg.endHeight;
            }

            currentX += seg.width;
        }

        return 0;
    }

    // Sprawdza czy panel mie≈õci siƒô w obszarze roboczym
    function checkPanelFits(x, y, width, height) {
        if (wallData.segments.length === 0) return true;

        // Sprawd≈∫ czy panel nie wychodzi poza szeroko≈õƒá obszaru
        let totalWidth = 0;
        wallData.segments.forEach(s => totalWidth += s.width);
        const maxX = 50 + totalWidth; // startX + suma szeroko≈õci segment√≥w

        if (x + width > maxX) return false;

        // Sprawd≈∫ czy panel nie wychodzi ponad wysoko≈õƒá w ka≈ºdym punkcie
        const samples = 5; // Sprawd≈∫ w 5 punktach szeroko≈õci panelu
        for (let i = 0; i <= samples; i++) {
            const sampleX = x + (width * i / samples);
            const maxHeight = getHeightAtPosition(sampleX);
            if (y + height > maxHeight) return false;
        }

        return true;
    }

    // Znajduje nastƒôpnƒÖ mo≈ºliwƒÖ pozycjƒô dla panelu
    function findNextValidPosition(width, height) {
        if (wallData.segments.length === 0) {
            return { x: 50, y: 0, mode: 'horizontal', fits: false };
        }

        // Zacznij od pozycji bazowej
        let x = 50, y = 0;

        if (panels.length > 0) {
            const lastPanel = panels[panels.length - 1];

            if (layoutMode === 'horizontal') {
                x = lastPanel.x + lastPanel.width;
                y = 0;
            } else {
                x = lastPanel.x;
                y = lastPanel.y + lastPanel.height;
            }
        }

        // Zapamiƒôtaj pierwotnƒÖ pozycjƒô (z layoutMode)
        const x1 = x;
        const y1 = y;

        // Sprawd≈∫ czy pasuje w bie≈ºƒÖcym trybie
        if (checkPanelFits(x, y, width, height)) {
            return { x, y, mode: layoutMode, fits: true };
        }

        // Je≈õli nie pasuje, spr√≥buj drugi tryb
        const altMode = layoutMode === 'horizontal' ? 'vertical' : 'horizontal';

        if (panels.length > 0) {
            const lastPanel = panels[panels.length - 1];

            if (altMode === 'horizontal') {
                x = lastPanel.x + lastPanel.width;
                y = 0;
            } else {
                x = lastPanel.x;
                y = lastPanel.y + lastPanel.height;
            }
        }

        if (checkPanelFits(x, y, width, height)) {
            return { x, y, mode: altMode, fits: true };
        }

        // Nic nie pasuje - zwr√≥ƒá PIERWOTNƒÑ pozycjƒô (z layoutMode)
        return { x: x1, y: y1, mode: layoutMode, fits: false };
    }

    function addPanel(width, height) {
        // Nowy panel otrzymuje styl z aktywnego narzƒôdzia (je≈õli to nie gumka)
        let style = { type: 'color', value: '#cccccc' }; // Default
        if (activeTool !== 'eraser') style = { ...activeTool };

        let x, y;

        // U≈ºyj pozycji z preview (je≈õli u≈ºytkownik kliknƒÖ≈Ç w obszar) lub auto pozycja
        if (previewPosition) {
            x = previewPosition.x;
            y = previewPosition.y;

            // Sprawd≈∫ kolizjƒô z innymi panelami (mo≈ºna dodaƒá panel czƒô≈õciowo poza obszarem, ale nie na innym panelu)
            if (checkPanelCollision(x, y, width, height)) {
                showProjectMessage('Panel koliduje z innym panelem! Kliknij w inne miejsce lub wybierz mniejszy panel.', 'error');
                return;
            }

            // Zresetuj preview po dodaniu
            previewPosition = null;
            previewLocked = false;
        } else {
            // Brak preview - u≈ºyj auto pozycji (sekwencyjne dodawanie)
            const nextPos = findNextValidPosition(width, height);

            if (!nextPos.fits) {
                showProjectMessage('Panel czƒô≈õciowo poza obszarem i zostanie uciƒôty', 'warning');
                // Pozw√≥l dodaƒá panel mimo ≈ºe czƒô≈õciowo poza obszarem
            }

            // Zaktualizuj tryb dla nastƒôpnego automatycznego dodawania
            if (nextPos.mode !== layoutMode) {
                layoutMode = nextPos.mode;
            }

            x = nextPos.x;
            y = nextPos.y;
        }

        panels.push({ width, height, x, y, style });

        // Zapamiƒôtaj rozmiar dla auto-preview
        lastUsedPanelSize = { width, height };

        draw();
        updateMappingUI();
    }

    function getSVGCoordinates(event) {
        const svg = document.querySelector('#svgWrapperFront svg');
        if (!svg) return null;

        const pt = svg.createSVGPoint();

        // Support both mouse and touch events
        if (event.touches && event.touches.length > 0) {
            pt.x = event.touches[0].clientX;
            pt.y = event.touches[0].clientY;
        } else if (event.changedTouches && event.changedTouches.length > 0) {
            pt.x = event.changedTouches[0].clientX;
            pt.y = event.changedTouches[0].clientY;
        } else {
            pt.x = event.clientX;
            pt.y = event.clientY;
        }

        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
        return { x: svgP.x, y: svgP.y };
    }

    // --- TOUCH EVENT HANDLERS (FAZA 2) ---

    function handleTouchStart(event) {
        const touches = event.touches;

        // Single finger touch only (no multi-touch gestures)
        if (touches.length === 1) {
            const touch = touches[0];
            touchState.active = true;
            touchState.startX = touch.clientX;
            touchState.startY = touch.clientY;
            touchState.lastX = touch.clientX;
            touchState.lastY = touch.clientY;
            touchState.startTime = Date.now();
            touchState.isPanning = false;

            // Store initial pan position
            touchState.initialPanX = touchState.panX;
            touchState.initialPanY = touchState.panY;

            // Start long press timer (600ms)
            touchState.longPressTimer = setTimeout(() => {
                handleLongPress(event);
            }, 600);
        }
    }

    function applyPanTransform() {
        const svgWrapper = document.getElementById('svgWrapperFront');
        if (svgWrapper) {
            svgWrapper.style.transform = `translate(${touchState.panX}px, ${touchState.panY}px)`;
        }
    }

    function handleTouchMove(event) {
        const touches = event.touches;

        // Single finger move (DRAG = PAN)
        if (touches.length === 1 && touchState.active) {
            const touch = touches[0];
            const deltaX = touch.clientX - touchState.startX;
            const deltaY = touch.clientY - touchState.startY;
            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);

            // If moved more than 10px, cancel long press and enable pan
            if (absDeltaX > 10 || absDeltaY > 10) {
                if (touchState.longPressTimer) {
                    clearTimeout(touchState.longPressTimer);
                    touchState.longPressTimer = null;
                }

                // Enable panning (always, not just when zoomed)
                if (!touchState.isPanning) {
                    touchState.isPanning = true;
                    event.preventDefault();
                }
            }

            // Pan mode (ALWAYS when dragging)
            if (touchState.isPanning) {
                event.preventDefault();
                touchState.panX = touchState.initialPanX + deltaX;
                touchState.panY = touchState.initialPanY + deltaY;
                applyPanTransform();
            }

            touchState.lastX = touch.clientX;
            touchState.lastY = touch.clientY;
        }
    }

    function handleTouchEnd(event) {
        const duration = Date.now() - touchState.startTime;
        const deltaX = Math.abs(touchState.lastX - touchState.startX);
        const deltaY = Math.abs(touchState.lastY - touchState.startY);

        // Clear long press timer
        if (touchState.longPressTimer) {
            clearTimeout(touchState.longPressTimer);
            touchState.longPressTimer = null;
        }

        // Panning ended
        if (touchState.isPanning) {
            event.preventDefault();
            touchState.isPanning = false;
            touchState.active = false;
            return;
        }

        // Tap detection (quick touch with minimal movement, not panning)
        if (touchState.active && !touchState.isPanning && duration < 300 && deltaX < 10 && deltaY < 10) {
            // Check if tap was on a panel
            const panelGroup = event.target.closest('g[onclick]');

            if (panelGroup) {
                // TAP ON PANEL - manually trigger the onclick
                event.preventDefault();
                const onclickAttr = panelGroup.getAttribute('onclick');
                if (onclickAttr) {
                    // Extract index from "onPanelClick(N)"
                    const match = onclickAttr.match(/onPanelClick\((\d+)\)/);
                    if (match) {
                        const index = parseInt(match[1]);
                        onPanelClick(index);
                    }
                }
            } else {
                // TAP ON CANVAS - add panel
                event.preventDefault();
                onCanvasClick(event);
            }
        }

        // Swipe detection (for future use - sidebar toggle)
        if (touchState.active && duration < 500) {
            const swipeThreshold = 50;

            if (deltaX > swipeThreshold && deltaX > deltaY * 2) {
                event.preventDefault();
                // Horizontal swipe detected
                if (touchState.lastX > touchState.startX) {
                    // Swipe right (future: open sidebar)
                    console.log('Swipe right detected');
                } else {
                    // Swipe left (future: close sidebar)
                    console.log('Swipe left detected');
                }
            }
        }

        // Reset touch state
        touchState.active = false;
    }

    function handleTouchCancel(event) {
        // Clear all touch state
        if (touchState.longPressTimer) {
            clearTimeout(touchState.longPressTimer);
            touchState.longPressTimer = null;
        }

        touchState.active = false;
    }

    function handleLongPress(event) {
        // Long press activates eraser mode
        const isEraserActive = activeTool === 'eraser' || activeTool.type === 'eraser';

        if (!isEraserActive) {
            setActiveTool('eraser');
            showProjectMessage('üóëÔ∏è Tryb usuwania aktywny (d≈Çugie naci≈õniƒôcie)', 'info', 2000);

            // Haptic feedback if available
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        }
    }

    function onCanvasMouseMove(event) {
        if (!lastUsedPanelSize) {
            previewPosition = null;
            return;
        }

        // Je≈õli preview jest zamro≈ºony (po snapie), nie aktualizuj pozycji
        if (previewLocked) {
            return;
        }

        const coords = getSVGCoordinates(event);
        if (!coords) return;

        // Przelicz wsp√≥≈Çrzƒôdne z SVG (y od g√≥ry) na nasze (y od do≈Çu)
        // Znajd≈∫ floorY z obecnego obszaru
        if (wallData.segments.length === 0) return;

        let maxH = 0;
        wallData.segments.forEach(s => {
            maxH = Math.max(maxH, s.startHeight, s.endHeight);
        });
        const padY = 60;
        const floorY = maxH + padY * 2 - padY;

        // coords.y jest od g√≥ry SVG, musimy przeliczyƒá na y od do≈Çu
        const yFromBottom = floorY - coords.y;
        const x = coords.x;

        // Smart snap (tylko podglƒÖd, bez kolizji - pokazujemy gdzie bƒôdzie)
        previewPosition = { x, y: yFromBottom };
        draw();
    }

    function onCanvasClick(event) {
        // Sprawd≈∫ czy klikniƒôto w panel (je≈õli tak, niech onPanelClick to obs≈Çu≈ºy)
        if (event.target.closest('g[onclick]')) return;

        if (!lastUsedPanelSize) return;

        const coords = getSVGCoordinates(event);
        if (!coords) return;

        // Przelicz wsp√≥≈Çrzƒôdne z SVG (y od g√≥ry) na nasze (y od do≈Çu)
        if (wallData.segments.length === 0) return;

        let maxH = 0;
        wallData.segments.forEach(s => {
            maxH = Math.max(maxH, s.startHeight, s.endHeight);
        });
        const padY = 60;
        const floorY = maxH + padY * 2 - padY;

        const yFromBottom = floorY - coords.y - lastUsedPanelSize.height; // Pozycja lewego dolnego rogu
        const x = coords.x;

        // Smart snap do pustej przestrzeni
        const snapped = findBestSnapPosition(x, yFromBottom, lastUsedPanelSize.width, lastUsedPanelSize.height);
        previewPosition = snapped; // Ustaw preview w snappowanym miejscu
        previewLocked = true; // Zamro≈∫ preview po snapie
        draw();
    }

    function onPanelClick(index) {
        const isEraserActive = activeTool === 'eraser' || activeTool.type === 'eraser';

        if (isEraserActive) {
            panels.splice(index, 1); // USU≈É
            // Eraser mode POZOSTAJE aktywny (nie wy≈ÇƒÖczamy)
        } else {
            panels[index].style = { ...activeTool }; // MALUJ
        }
        draw();
        updateMappingUI();
    }

    function undoPanel() { panels.pop(); draw(); updateMappingUI(); }

    function clearWorkspace() {
        if (panels.length === 0) {
            showProjectMessage('Obszar roboczy jest ju≈º pusty!', 'info');
            return;
        }
        showProjectConfirm(`Czy na pewno chcesz usunƒÖƒá wszystkie panele (${panels.length} szt)?`, () => {
            panels = [];
            draw();
            updateMappingUI();
        });
    }

    // --- 4. ZAPIS (FIFO) ---
    function saveCurrentLayout() {
        let saves = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        saves.unshift({
            id: Date.now(),
            date: new Date().toLocaleTimeString(),
            wall: wallData,
            panels: panels,
            variants: variants,
            mapping: styleMapping,
            mode: layoutMode,
            depth: panelDepth
        });
        if(saves.length > 5) saves.pop();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(saves));
        renderSaves();
    }

    function renderSaves() {
        const c = document.getElementById('savesContainer');
        c.innerHTML = '';
        const saves = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        if(saves.length===0) c.innerHTML='<div style="color:#999; font-size:0.8em;">Pusto</div>';

        saves.forEach(s => {
            const d = document.createElement('div'); d.className='save-slot';
            d.innerHTML = `<span>${s.date} (${s.panels.length} el.)</span>
                <button class="btn-secondary" style="padding:2px 5px; font-size:0.8em;" onclick="loadSave(${s.id})">Wczytaj</button>`;
            c.appendChild(d);
        });
    }

    function loadSave(id) {
        const s = JSON.parse(localStorage.getItem(STORAGE_KEY)).find(x=>x.id===id);
        if(s && confirm("Wczytaƒá projekt?")) {
            wallData = s.wall;
            panels = s.panels;
            variants = s.variants || variants;
            styleMapping = s.mapping || {};
            layoutMode = s.mode || 'horizontal';
            panelDepth = s.depth || 2.5;

            // Synchronizuj checkbox pianki
            document.getElementById('optFoam').checked = (panelDepth === 5.0);

            draw();
            renderSegmentsList();
            renderVariantConfig();
            renderTopBar();
            updateMappingUI();
        }
    }

    // --- 5. LOGIKA OBSZARU ROBOCZEGO ---
    function loadPresetWorkspace() {
        // Preset U-shaped: seg1‚Üíseg2 (90¬∞), seg2‚Üíseg3 (180¬∞), seg3‚Üíseg4 (90¬∞)
        wallData.segments = [
            {width: 100, startHeight: 140, endHeight: 140, angle: 180}, // Pierwszy segment (angle nie ma znaczenia)
            {width: 200, startHeight: 140, endHeight: 140, angle: 90},  // Skrƒôt 90¬∞ w prawo
            {width: 100, startHeight: 140, endHeight: 140, angle: 180}, // Kontynuacja prosto
            {width: 200, startHeight: 140, endHeight: 140, angle: 90}   // Skrƒôt 90¬∞ w prawo
        ];
        renderSegmentsList();
        draw();
        updateMappingUI();
    }

    function addSegment() {
        const w = parseFloat(document.getElementById('segWidth').value);
        const sh = parseFloat(document.getElementById('segStartHeight').value);
        const eh = parseFloat(document.getElementById('segEndHeight').value);

        // Walidacja: sprawd≈∫ czy wszystkie pola sƒÖ wype≈Çnione
        if (!w || !sh || !eh || w <= 0 || sh <= 0 || eh <= 0) {
            alert('Wype≈Çnij wszystkie pola (szeroko≈õƒá, wysoko≈õƒá poczƒÖtkowa i ko≈Ñcowa) warto≈õciami wiƒôkszymi od 0');
            return;
        }

        wallData.segments.push({width: w, startHeight: sh, endHeight: eh, angle: 180}); // Default 180¬∞ (linia prosta)
        document.getElementById('segWidth').value = '';
        document.getElementById('segEndHeight').value = '';

        // Auto-wype≈Çnianie: przepisz wysoko≈õƒá ko≈ÑcowƒÖ do pola poczƒÖtkowej
        document.getElementById('segStartHeight').value = eh;

        renderSegmentsList();
        draw();
        updateMappingUI();
    }

    function removeSegment(i) {
        wallData.segments.splice(i, 1);

        // Zaktualizuj masterSegmentIndex je≈õli potrzeba
        if (wallData.masterSegmentIndex >= wallData.segments.length) {
            wallData.masterSegmentIndex = Math.max(0, wallData.segments.length - 1);
        }

        renderSegmentsList();
        draw();
        updateMappingUI();
    }

    function updateSegmentAngle(index, newAngle) {
        const angle = parseFloat(newAngle);
        if (angle >= 45 && angle <= 270) {
            wallData.segments[index].angle = angle;
            renderSegmentsList();
            draw();
        }
    }

    function cycleAngle(index, direction) {
        const angles = [90, 180, 270];
        const currentAngle = wallData.segments[index].angle || 180;
        const currentIndex = angles.indexOf(currentAngle);

        let newIndex;
        if (currentIndex === -1) {
            // Je≈õli kƒÖt nie jest w dozwolonych warto≈õciach, ustaw 180¬∞
            newIndex = 1; // 180¬∞
        } else {
            newIndex = (currentIndex + direction + angles.length) % angles.length;
        }

        wallData.segments[index].angle = angles[newIndex];
        renderSegmentsList();
        draw();
    }

    function setMasterSegment(index) {
        wallData.masterSegmentIndex = index;
        renderSegmentsList();
        draw();
    }

    function resetWall() {
        if(confirm("Resetowaƒá obszar roboczy?")) {
            wallData.segments = [];
            wallData.masterSegmentIndex = 0;
            document.getElementById('segStartHeight').value = '';
            document.getElementById('segEndHeight').value = '';
            renderSegmentsList();
            draw();
            updateMappingUI();
        }
    }

    function getAngleIcon(angle) {
        if (angle < 100) return '‚Ü±'; // Skrƒôt w prawo (90¬∞ itp.)
        if (angle > 170 && angle < 190) return '‚îÄ'; // Linia prosta (180¬∞)
        if (angle > 260) return '‚Ü∞'; // Skrƒôt w lewo (270¬∞)
        return '‚Ü∑'; // Inne kƒÖty
    }

    function renderSegmentsList() {
        const c = document.getElementById('segmentsContainer');
        c.innerHTML = '';

        wallData.segments.forEach((s, i) => {
            // Okre≈õl ikonƒô kszta≈Çtu: prostokƒÖt (‚ñ≠) lub trapez (‚è¢)
            const shapeIcon = s.startHeight === s.endHeight ? '‚ñ≠' : '‚è¢';
            const angleIcon = getAngleIcon(s.angle || 180);
            const isMaster = (wallData.masterSegmentIndex === i);

            const row = document.createElement('div');
            row.className = 'segment-row';

            const iconSpan = document.createElement('span');
            iconSpan.className = 'segment-icon';
            iconSpan.title = s.startHeight === s.endHeight ? 'ProstokƒÖt' : 'Trapez';
            iconSpan.textContent = shapeIcon;

            const infoDiv = document.createElement('div');
            infoDiv.className = 'segment-info';
            infoDiv.innerHTML = `
                <input type="radio" name="masterSegment" class="master-radio"
                       ${isMaster ? 'checked' : ''}
                       onchange="setMasterSegment(${i})"
                       title="Ustaw jako master (bazowy) segment">
                ${i+1}. <b>${s.width}</b>cm | ${s.startHeight}‚Üí${s.endHeight}cm<br>
                <span style="font-size:0.8em; color:#666; margin-left:20px;">
                    ${angleIcon} KƒÖt:
                    ${i === 0 ?
                        `<input type="text" class="segment-angle-input" value="--" readonly disabled title="Pierwszy segment nie ma kƒÖta ≈ÇƒÖczenia">¬∞` :
                        `<button class="angle-btn" onclick="cycleAngle(${i}, -1)">-</button>
                         <input type="text" class="segment-angle-input" value="${s.angle || 180}" readonly>¬∞
                         <button class="angle-btn" onclick="cycleAngle(${i}, 1)">+</button>`
                    }
                </span>`;

            const btnX = document.createElement('button');
            btnX.className = 'btn-x';
            btnX.textContent = 'X';
            btnX.onclick = () => removeSegment(i);

            row.appendChild(iconSpan);
            row.appendChild(infoDiv);
            row.appendChild(btnX);
            c.appendChild(row);
        });
    }

    // --- 6. WYCENA & MAPOWANIE ---
    function updateMappingUI() {
        const used = [...new Set(panels.map(p=>p.style.value))];
        const c = document.getElementById('mappingContainer'); c.innerHTML='';
        if(used.length===0) { c.innerHTML='<div style="color:#999; font-size:0.8em;">Brak paneli</div>'; recalculatePrice(); return; }

        used.forEach(val => {
            const row = document.createElement('div'); row.className='mapping-item';
            const sw = document.createElement('div'); sw.className='map-swatch';
            if(val.includes('data:image')) { sw.style.backgroundImage=`url('${val}')`; sw.style.backgroundSize='cover'; }
            else sw.style.backgroundColor=val;

            const sel = document.createElement('select'); sel.className='map-select';
            sel.onchange = (e) => { styleMapping[val]=e.target.value; recalculatePrice(); };

            ['Standard','Premium','Exclusive'].forEach(grp => {
                const g = document.createElement('optgroup'); g.label=grp;
                Collections[grp].forEach(col => {
                    const o = document.createElement('option'); o.value=col; o.text=col;
                    if(styleMapping[val]===col) o.selected=true;
                    g.appendChild(o);
                });
                sel.appendChild(g);
            });
            if(!styleMapping[val]) { styleMapping[val]=Collections.Standard[0]; sel.value=Collections.Standard[0]; }

            row.appendChild(sw); row.appendChild(sel); c.appendChild(row);
        });
        recalculatePrice();
    }

    function recalculatePrice() {
        const opts = {
            foam: document.getElementById('optFoam').checked,
            velcro: document.getElementById('optVelcro').checked,
            glue: parseInt(document.getElementById('optGlue').value)||0,
            outlets: parseInt(document.getElementById('optOutlets')?.value || 0),
            shipping: document.getElementById('optShipping').checked
        };

        if (panels.length === 0) {
            document.getElementById('totalPriceDisplay').innerText = "0.00 z≈Ç";
            document.getElementById('priceDetails').innerHTML = '<div style="color:#999; font-size:0.9em;">Brak paneli</div>';
            return;
        }

        // GRUPOWANIE PANELI (rozmiar √ó tkanina)
        const groups = {};
        let totalArea = 0;

        panels.forEach(p => {
            const col = styleMapping[p.style.value] || 'DIANA';
            let category = 'Standard';
            if (Collections.Premium.includes(col)) category = 'Premium';
            if (Collections.Exclusive.includes(col)) category = 'Exclusive';

            const key = `${p.width}x${p.height}`;
            const groupKey = `${key}|${col}|${category}`;

            if (!groups[groupKey]) {
                groups[groupKey] = {
                    size: `${p.width}√ó${p.height} cm`,
                    fabric: col,
                    category: category,
                    count: 0,
                    unitPrice: 0,
                    area: 0
                };
            }

            // Pobierz cenƒô jednostkowƒÖ
            let base = 0;
            if (category === 'Standard' && RozmStandard[key]) {
                base = RozmStandard[key];
            } else if (category === 'Premium' && RozmPremium[key]) {
                base = RozmPremium[key];
            } else if (category === 'Exclusive' && RozmExclusive[key]) {
                base = RozmExclusive[key];
            } else {
                base = ((p.width * p.height) / 10000) * 300;
            }

            groups[groupKey].count++;
            groups[groupKey].unitPrice = base;
            groups[groupKey].area += (p.width * p.height) / 10000;
            totalArea += (p.width * p.height) / 10000;
        });

        // GENEROWANIE LISTY MATERIA≈Å√ìW
        let html = '<div style="font-size:0.85em; line-height:1.6;">';

        // === PANELE ===
        html += '<div style="font-weight:bold; margin-bottom:8px; padding-bottom:4px; border-bottom:2px solid #28a745; color:#28a745;">‚ïê‚ïê‚ïê PANELE ‚ïê‚ïê‚ïê</div>';
        let panelsTotal = 0;

        Object.values(groups).forEach(g => {
            const subtotal = g.count * g.unitPrice;
            panelsTotal += subtotal;
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                <span style="font-weight:500;">${g.size}</span>
                <span style="color:#666;">(${g.fabric})</span> -
                ${g.count} szt √ó ${g.unitPrice.toFixed(2)} z≈Ç =
                <span style="font-weight:bold;">${subtotal.toFixed(2)} z≈Ç</span>
            </div>`;
        });

        // === DODATKI ===
        html += '<div style="font-weight:bold; margin:12px 0 8px 0; padding-bottom:4px; border-bottom:2px solid #ff9800; color:#ff9800;">‚ïê‚ïê‚ïê DODATKI ‚ïê‚ïê‚ïê</div>';
        let extrasTotal = 0;

        // Pianka (obecna logika jest prawid≈Çowa)
        if (opts.foam) {
            let foamCost = 0;
            panels.forEach(p => {
                const m2 = (p.width * p.height) / 10000;
                let cost = 0;
                if (m2 < 0.4) cost = 6;
                else if (m2 < 0.9) cost = 15;
                else if (m2 < 1.5) cost = 30;
                else if (m2 < 2.0) cost = 60;
                else cost = 100;
                foamCost += cost;
            });
            extrasTotal += foamCost;
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                ‚òë Podw√≥jna pianka (5cm) - ${panels.length} paneli (6-100 z≈Ç) =
                <span style="font-weight:bold;">${foamCost.toFixed(2)} z≈Ç</span>
            </div>`;
        }

        // Rzep
        if (opts.velcro) {
            let velcroCost = 0;
            panels.forEach(p => {
                const m2 = (p.width * p.height) / 10000;
                let cost = 0;
                if (m2 < 0.4) cost = 8;
                else if (m2 < 0.9) cost = 20;
                else if (m2 < 1.5) cost = 40;
                else if (m2 < 2.0) cost = 70;
                else cost = 120;
                velcroCost += cost;
            });
            extrasTotal += velcroCost;
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                ‚òë Rzep monta≈ºowy - ${panels.length} paneli (8-120 z≈Ç) =
                <span style="font-weight:bold;">${velcroCost.toFixed(2)} z≈Ç</span>
            </div>`;
        }

        // Otwory na kontakt
        if (opts.outlets > 0) {
            const outletsCost = opts.outlets * 39;
            extrasTotal += outletsCost;
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                Otwory na kontakt - ${opts.outlets} szt √ó 39 z≈Ç =
                <span style="font-weight:bold;">${outletsCost.toFixed(2)} z≈Ç</span>
            </div>`;
        }

        // Klej
        if (opts.glue > 0) {
            const glueCost = opts.glue * 36;
            extrasTotal += glueCost;
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                Klej monta≈ºowy - ${opts.glue} szt √ó 36 z≈Ç =
                <span style="font-weight:bold;">${glueCost.toFixed(2)} z≈Ç</span>
            </div>`;
        }

        if (extrasTotal === 0) {
            html += '<div style="margin-bottom:4px; padding-left:8px; color:#999;">Brak wybranych dodatk√≥w</div>';
        }

        // === LOGISTYKA ===
        html += '<div style="font-weight:bold; margin:12px 0 8px 0; padding-bottom:4px; border-bottom:2px solid #2196f3; color:#2196f3;">‚ïê‚ïê‚ïê LOGISTYKA ‚ïê‚ïê‚ïê</div>';
        let shippingCost = 0;
        if (opts.shipping) {
            shippingCost = 39; // Uproszczona wersja, mo≈ºna rozszerzyƒá o kalkulacjƒô gabarytu
            html += `<div style="margin-bottom:4px; padding-left:8px;">
                ‚òë Wysy≈Çka = <span style="font-weight:bold;">${shippingCost.toFixed(2)} z≈Ç</span>
            </div>`;
        } else {
            html += '<div style="margin-bottom:4px; padding-left:8px; color:#999;">Brak wysy≈Çki</div>';
        }

        // === PODSUMOWANIE ===
        html += '<div style="font-weight:bold; margin:12px 0 8px 0; padding-bottom:4px; border-bottom:2px solid #333; color:#333;">‚ïê‚ïê‚ïê PODSUMOWANIE ‚ïê‚ïê‚ïê</div>';
        html += `<div style="margin-bottom:4px; padding-left:8px;">
            Suma paneli: <span style="font-weight:bold;">${panelsTotal.toFixed(2)} z≈Ç</span>
            <span style="color:#666;">(${panels.length} szt, ${totalArea.toFixed(2)} m¬≤)</span>
        </div>`;
        html += `<div style="margin-bottom:4px; padding-left:8px;">
            Suma dodatk√≥w: <span style="font-weight:bold;">${extrasTotal.toFixed(2)} z≈Ç</span>
        </div>`;
        html += `<div style="margin-bottom:4px; padding-left:8px;">
            Wysy≈Çka: <span style="font-weight:bold;">${shippingCost.toFixed(2)} z≈Ç</span>
        </div>`;
        html += '<div style="margin-top:8px; padding-top:8px; border-top:2px solid #333;"></div>';

        const grandTotal = panelsTotal + extrasTotal + shippingCost;
        html += '</div>';

        document.getElementById('totalPriceDisplay').innerText = grandTotal.toFixed(2) + " z≈Ç";
        document.getElementById('priceDetails').innerHTML = html;
    }

    // --- 7. WIZUALIZACJA ---
    function draw() {
        drawFrontView();
        drawTopView();
    }

    function drawFrontView() {
        const svg = document.getElementById('svgWrapperFront');

        if (wallData.segments.length === 0) {
            // Brak segment√≥w - poka≈º pustƒÖ przestrze≈Ñ
            svg.innerHTML = `<svg width="300px" viewBox="0 0 300 200">
                <text x="150" y="100" text-anchor="middle" fill="#999" font-size="14">
                    Dodaj segmenty obszaru
                </text>
            </svg>`;
            return;
        }

        let totalW = 0, maxH = 0;
        wallData.segments.forEach(s => {
            totalW += s.width;
            maxH = Math.max(maxH, s.startHeight, s.endHeight);
        });

        const padX = 50, padY = 60;
        const W = totalW + padX * 2, H = maxH + padY * 2;
        const startX = padX, floorY = H - padY;

        // Budowanie ≈õcie≈ºki obszaru roboczego
        let cx = startX;
        let d = `M ${cx} ${floorY}`;

        // Linia g√≥rna (od lewej do prawej)
        wallData.segments.forEach(s => {
            d += ` L ${cx} ${floorY - s.startHeight}`;
            cx += s.width;
            d += ` L ${cx} ${floorY - s.endHeight}`;
        });

        // Zamkniƒôcie ≈õcie≈ºki (prawa krawƒôd≈∫ w d√≥≈Ç, linia dolna)
        d += ` L ${cx} ${floorY} Z`;

        let defs = `<clipPath id="wc"><path d="${d}"/></clipPath>`;
        const uTex = [...new Set(panels.filter(p=>p.style.type==='image').map(p=>p.style.value))];
        uTex.forEach((src,i)=> defs+=`<pattern id="pt${i}" patternUnits="userSpaceOnUse" width="50" height="50"><image href="${src}" x="0" y="0" width="50" height="50" preserveAspectRatio="xMidYMid slice"/></pattern>`);

        const pSvg = panels.map((p,i)=>{
            const fill = p.style.type==='color' ? p.style.value : `url(#pt${uTex.indexOf(p.style.value)})`;
            const cls = activeTool==='eraser' ? 'panel-rect delete-mode' : 'panel-rect';

            // Pozycja panelu (x,y od lewego dolnego rogu)
            const panelX = p.x;
            const panelY = floorY - p.y - p.height;

            // Sprawd≈∫ czy panel wystaje poza obszar
            const fits = checkPanelFits(p.x, p.y, p.width, p.height);

            // Wymiary WEWNƒÑTRZ panelu
            // Szeroko≈õƒá - poziomo na dole
            const widthTextY = panelY + p.height - 8;
            // Wysoko≈õƒá - pionowo (obr√≥cona 90¬∞) po prawej stronie
            const heightTextX = panelX + p.width - 8;
            const heightTextY = panelY + p.height/2;

            // Automatyczny kontrast tekstu na podstawie koloru t≈Ça
            const textColor = getContrastColor(p.style.value);

            return `<g onclick="onPanelClick(${i})">
                ${!fits ? `<rect x="${panelX}" y="${panelY}" width="${p.width}" height="${p.height}" fill="${fill}" opacity="0.3" stroke="#999" stroke-width="2" stroke-dasharray="5,5" pointer-events="none"/>` : ''}
                <rect x="${panelX}" y="${panelY}" width="${p.width}" height="${p.height}" fill="${fill}" ${!fits ? 'clip-path="url(#wc)"' : ''} class="${cls}"/>
                <text x="${panelX + p.width/2}" y="${widthTextY}" text-anchor="middle" class="dim-text-panel" fill="${textColor.fill}" style="text-shadow: ${textColor.shadow}">${p.width}</text>
                <text x="${heightTextX}" y="${heightTextY}" text-anchor="middle" class="dim-text-panel" fill="${textColor.fill}" style="text-shadow: ${textColor.shadow}" transform="rotate(-90 ${heightTextX} ${heightTextY})">${p.height}</text>
                <line x1="${panelX}" y1="${panelY}" x2="${panelX}" y2="${panelY + p.height}" stroke="rgba(0,0,0,0.15)" stroke-width="1"/>
                <line x1="${panelX + p.width}" y1="${panelY}" x2="${panelX + p.width}" y2="${panelY + p.height}" stroke="rgba(0,0,0,0.15)" stroke-width="1"/>
            </g>`;
        }).join('');

        // Preview nastƒôpnego panelu (z pozycji myszy lub auto)
        let previewSVG = '';
        const previewSize = selectedPanelSize || lastUsedPanelSize; // Hover lub ostatnio u≈ºyty

        if (previewSize) {
            let prevX, prevY;

            // U≈ºyj pozycji z previewPosition (ju≈º snappowanej) lub znajd≈∫ nastƒôpnƒÖ wolnƒÖ
            if (previewPosition) {
                prevX = previewPosition.x;
                prevY = floorY - previewPosition.y - previewSize.height;
            } else {
                // Fallback: znajd≈∫ nastƒôpnƒÖ pozycjƒô automatycznie
                const nextPos = findNextValidPosition(previewSize.width, previewSize.height);
                if (!nextPos.fits) return; // Brak miejsca

                prevX = nextPos.x;
                prevY = floorY - nextPos.y - previewSize.height;
            }

            // Sprawd≈∫ czy panel mie≈õci siƒô (dla kolorowania)
            const yFromBottom = floorY - prevY - previewSize.height;
            const fits = checkPanelFits(prevX, yFromBottom, previewSize.width, previewSize.height);
            const hasCollision = checkPanelCollision(prevX, yFromBottom, previewSize.width, previewSize.height);

            // Kolor preview: czerwony (kolizja), ≈º√≥≈Çty (poza obszarem), zielony (hover OK), niebieski (auto-preview OK)
            const isHover = selectedPanelSize !== null;
            let strokeColor, fillColor;
            if (hasCollision) {
                // üî¥ Czerwony - kolizja z innym panelem (BLOKADA)
                strokeColor = '#dc3545';
                fillColor = 'rgba(220, 53, 69, 0.15)';
            } else if (!fits) {
                // üü° ≈ª√≥≈Çty - czƒô≈õciowo poza obszarem (OSTRZE≈ªENIE - mo≈ºna dodaƒá)
                strokeColor = '#ffc107';
                fillColor = 'rgba(255, 193, 7, 0.15)';
            } else if (isHover) {
                // üü¢ Zielony - hover, wszystko OK
                strokeColor = '#28a745';
                fillColor = 'rgba(40, 167, 69, 0.2)';
            } else {
                // üîµ Niebieski - auto-preview, wszystko OK
                strokeColor = '#007bff';
                fillColor = 'rgba(0, 123, 255, 0.15)';
            }

            // Prze≈∫roczysty prostokƒÖt
            previewSVG += `<rect x="${prevX}" y="${prevY}" width="${previewSize.width}" height="${previewSize.height}"
                fill="${fillColor}" stroke="${strokeColor}" stroke-width="2" stroke-dasharray="5,5" pointer-events="none"/>`;

            // Strza≈Çka ‚Üô w lewym dolnym rogu (wewnƒÖtrz preview)
            const arrowX = prevX + 15; // 15px od lewej krawƒôdzi
            const arrowY = prevY + previewSize.height - 15; // 15px od dolnej krawƒôdzi

            previewSVG += `<text x="${arrowX}" y="${arrowY}" font-size="20" fill="${strokeColor}" font-weight="bold" pointer-events="none">‚Üô</text>`;
        }

        // Wymiarowanie segment√≥w (wysoko≈õci)
        let dimensionsSVG = '';
        let segX = startX;
        wallData.segments.forEach((s, idx) => {
            const topYStart = floorY - s.startHeight;
            const topYEnd = floorY - s.endHeight;

            // Linia wymiarowa na poczƒÖtku segmentu
            dimensionsSVG += `<line x1="${segX}" y1="${floorY}" x2="${segX}" y2="${topYStart - 10}" class="dim-line" stroke="#888" />`;
            dimensionsSVG += `<text x="${segX + 5}" y="${topYStart - 15}" text-anchor="start" class="dim-text-external" font-weight="bold">${s.startHeight}</text>`;

            // Wymiar szeroko≈õci segmentu (na dole)
            const segMidX = segX + s.width / 2;
            const dimY = floorY + 30;
            dimensionsSVG += `<line x1="${segX}" y1="${dimY}" x2="${segX + s.width}" y2="${dimY}" stroke="#444" stroke-width="1" />`;
            dimensionsSVG += `<line x1="${segX}" y1="${dimY-5}" x2="${segX}" y2="${dimY+5}" stroke="#444" stroke-width="1" />`;
            dimensionsSVG += `<line x1="${segX + s.width}" y1="${dimY-5}" x2="${segX + s.width}" y2="${dimY+5}" stroke="#444" stroke-width="1" />`;
            dimensionsSVG += `<text x="${segMidX}" y="${dimY + 15}" text-anchor="middle" class="dim-text-external" font-size="12" font-weight="bold">${s.width}</text>`;

            segX += s.width;

            // Linia wymiarowa na ko≈Ñcu ostatniego segmentu
            if (idx === wallData.segments.length - 1) {
                dimensionsSVG += `<line x1="${segX}" y1="${floorY}" x2="${segX}" y2="${topYEnd - 10}" class="dim-line" stroke="#888" />`;
                dimensionsSVG += `<text x="${segX - 5}" y="${topYEnd - 15}" text-anchor="end" class="dim-text-external" font-weight="bold">${s.endHeight}</text>`;
            }
        });

        svg.innerHTML = `<svg width="${W*zoomLevel}px" viewBox="0 0 ${W} ${H}">
            <defs>${defs}</defs>
            <path d="${d}" class="wall-bg"/>
            ${pSvg}
            ${previewSVG}
            <path d="${d}" fill="none" stroke="#555" stroke-width="2"/>
            ${dimensionsSVG}
        </svg>`;
    }

    function drawTopView() {
        const svg = document.getElementById('svgWrapperTop');

        if (wallData.segments.length === 0) {
            svg.innerHTML = `<svg width="300px" viewBox="0 0 300 200">
                <text x="150" y="100" text-anchor="middle" fill="#999" font-size="14">
                    Dodaj segmenty aby zobaczyƒá widok z g√≥ry
                </text>
            </svg>`;
            return;
        }

        const wallDepth = 2.5; // Sta≈Ça grubo≈õƒá obszaru roboczego (nie zale≈ºy od pianki)

        // Oblicz pozycje 2D segment√≥w na podstawie kƒÖt√≥w (trigonometria)
        let positions = [];
        let currentX = 0;
        let currentY = 0;
        let currentAngle = 0; // KƒÖt w radianach (0 = w prawo)

        wallData.segments.forEach((seg, idx) => {
            // Zapisz pozycjƒô STARTOWƒÑ tego segmentu z jego OBECNYM kƒÖtem
            positions.push({ x: currentX, y: currentY, angle: currentAngle, width: seg.width });

            // Oblicz przemieszczenie wed≈Çug obecnego kƒÖta
            const dx = seg.width * Math.cos(currentAngle);
            const dy = seg.width * Math.sin(currentAngle);
            currentX += dx;
            currentY += dy;

            // Zaktualizuj kƒÖt dla NASTƒòPNEGO segmentu (je≈õli nie ostatni)
            if (idx < wallData.segments.length - 1) {
                const nextSeg = wallData.segments[idx + 1];
                // angle: 180¬∞ = kontynuacja, 90¬∞ = skrƒôt w prawo, 270¬∞ = skrƒôt w lewo
                const turnAngle = nextSeg.angle - 180; // -90¬∞ (w prawo), 0¬∞ (prosto), +90¬∞ (w lewo)
                currentAngle += (turnAngle * Math.PI / 180); // Konwersja na radiany
            }
        });

        // Przesu≈Ñ i obr√≥ƒá wszystkie pozycje wzglƒôdem master segmentu
        const masterIdx = wallData.masterSegmentIndex || 0;
        const masterPos = positions[masterIdx];
        const masterAngle = masterPos.angle;

        // Przetw√≥rz wszystkie pozycje: przesu≈Ñ i obr√≥ƒá wzglƒôdem mastera
        positions = positions.map(pos => {
            // Przesu≈Ñ pozycjƒô wzglƒôdem mastera
            let relX = pos.x - masterPos.x;
            let relY = pos.y - masterPos.y;

            // Obr√≥ƒá o -masterAngle (aby master mia≈Ç kƒÖt 0)
            const cosA = Math.cos(-masterAngle);
            const sinA = Math.sin(-masterAngle);
            const rotatedX = relX * cosA - relY * sinA;
            const rotatedY = relX * sinA + relY * cosA;

            return {
                x: rotatedX,
                y: rotatedY,
                angle: pos.angle - masterAngle,
                width: pos.width
            };
        });

        // Oblicz pozycjƒô X mastera w widoku frontalnym (wyr√≥wnanie lewo-prawo)
        const frontViewStartX = 50; // padX z widoku frontalnego
        let masterFrontX = frontViewStartX;
        for (let i = 0; i < masterIdx; i++) {
            masterFrontX += wallData.segments[i].width;
        }

        // Oblicz totalW - suma szeroko≈õci wszystkich segment√≥w (TAK SAMO jak w widoku frontalnym!)
        let totalW = 0;
        wallData.segments.forEach(s => totalW += s.width);

        // Znajd≈∫ granice dla centrowania (tylko w pionie - Y)
        let minY = Math.min(...positions.map(p => p.y));
        let maxY = Math.max(...positions.map(p => p.y));

        // Dodaj padding dla grubo≈õci ≈õciany
        minY -= wallDepth;
        maxY += wallDepth;

        const rangeY = maxY - minY;
        const padX = 50, padY = 50;
        const W = totalW + padX * 2; // TAK SAMO jak w widoku frontalnym - wa≈ºne dla wyr√≥wnania!
        const H = rangeY + padY * 2;

        // Przesuniƒôcie: master segment ma byƒá w pozycji masterFrontX (wyr√≥wnanie z widokiem frontalnym)
        const offsetX = masterFrontX;
        const offsetY = -minY + padY;

        // Rysowanie segment√≥w jako prostokƒÖt√≥w (szeroko≈õƒá √ó g≈Çƒôboko≈õƒá)
        let segmentsSVG = '';
        for (let i = 0; i < wallData.segments.length; i++) {
            const seg = wallData.segments[i];
            const pos = positions[i];
            const angle = pos.angle * 180 / Math.PI; // Konwersja na stopnie

            const x = pos.x + offsetX;
            const y = pos.y + offsetY;

            // ProstokƒÖt: szeroko≈õƒá segmentu √ó grubo≈õƒá ≈õciany
            segmentsSVG += `<rect x="0" y="${-wallDepth/2}" width="${seg.width}" height="${wallDepth}"
                fill="#7fa8d1" stroke="#4a7ba7" stroke-width="2"
                transform="translate(${x}, ${y}) rotate(${angle})" />`;

            // Etykieta szeroko≈õci (w ≈õrodku segmentu)
            const midX = x + (seg.width / 2) * Math.cos(pos.angle);
            const midY = y + (seg.width / 2) * Math.sin(pos.angle);
            segmentsSVG += `<text x="${midX}" y="${midY}" text-anchor="middle" font-size="11" fill="#fff" font-weight="bold"
                style="text-shadow: 0 0 3px rgba(0,0,0,0.8)">${seg.width}</text>`;

            // Etykieta kƒÖta (przy punkcie ≈ÇƒÖczenia segment√≥w, je≈õli nie 180¬∞)
            if (i > 0 && wallData.segments[i].angle !== 180) {
                const labelText = `${wallData.segments[i].angle}¬∞`;
                const labelFontSize = 10;
                const labelPadding = 3;

                // Offset od punktu ≈ÇƒÖczenia (na zewnƒÖtrz kƒÖta)
                const labelOffsetDist = 15;
                const labelX = x + labelOffsetDist * Math.cos(pos.angle - Math.PI/4);
                const labelY = y + labelOffsetDist * Math.sin(pos.angle - Math.PI/4);

                // Wymiary t≈Ça (przybli≈ºone)
                const textWidth = labelText.length * 6;
                const textHeight = 14;

                // T≈Ço pod tekstem (prostokƒÖt z ramkƒÖ)
                segmentsSVG += `<rect x="${labelX - textWidth/2 - labelPadding}" y="${labelY - textHeight/2 - labelPadding}"
                    width="${textWidth + labelPadding*2}" height="${textHeight + labelPadding*2}"
                    fill="#fff" stroke="#ff6b35" stroke-width="1.5" rx="3" opacity="0.95" />`;

                // Tekst kƒÖta
                segmentsSVG += `<text x="${labelX}" y="${labelY + 3}" text-anchor="middle"
                    font-size="${labelFontSize}" fill="#ff6b35" font-weight="bold">${labelText}</text>`;
            }
        }

        svg.innerHTML = `<svg width="${W*zoomLevel}px" viewBox="0 0 ${W} ${H}">
            <rect width="${W}" height="${H}" fill="#f8f9fa"/>
            ${segmentsSVG}
        </svg>`;
    }

    function changeZoom(d) {
        zoomLevel = Math.max(0.2, Math.min(3.0, zoomLevel + d));
        document.getElementById('zoomLabel').innerText = Math.round(zoomLevel*100)+'%';

        // Reset pan when zooming out to 100% or less
        if (zoomLevel <= 1.0) {
            touchState.panX = 0;
            touchState.panY = 0;
            applyPanTransform();
        }

        draw();
    }
</script>

</body>
</html>
